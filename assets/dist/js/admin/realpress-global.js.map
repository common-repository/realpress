{"version":3,"file":"admin/realpress-global.js","mappings":";;;;;;;;;;;;;;AAAA,MAAMA,qBAAqB,GAAG,MAAM;EAChC,MAAMC,oBAAoB,GAAGC,QAAQ,CAACC,gBAAT,CAA0B,qCAA1B,CAA7B;EACA,MAAMC,aAAa,GAAGC,uBAAuB,CAACC,cAAxB,IAA0C,EAAhE;;EAEA,IAAI,CAACL,oBAAL,EAA2B;IACvB;EACH;;EACD,MAAM;IAACM;EAAD,IAAOC,EAAE,CAACC,IAAhB;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,oBAAoB,CAACU,MAAzC,EAAiDD,CAAC,EAAlD,EAAsD;IAClD,MAAME,mBAAmB,GAAGX,oBAAoB,CAACS,CAAD,CAAhD;IACA,MAAMG,YAAY,GAAGD,mBAAmB,CAACE,aAApB,CAAkC,yDAAlC,CAArB;IACA,MAAMC,iBAAiB,GAAGH,mBAAmB,CAACE,aAApB,CAAkC,8CAAlC,CAA1B;;IACA,IAAI,CAACC,iBAAL,EAAwB;MACpB;IACH;;IACD,MAAMC,iBAAiB,GAAGJ,mBAAmB,CAACE,aAApB,CAAkC,kCAAlC,CAA1B;IACA,MAAMG,iBAAiB,GAAGL,mBAAmB,CAACE,aAApB,CAAkC,mCAAlC,CAA1B;IACAC,iBAAiB,CAACG,gBAAlB,CAAmC,OAAnC,EAA4C,YAAY;MACpDL,YAAY,CAACM,KAAb,CAAmBC,OAAnB,GAA6B,MAA7B;MACA,KAAKD,KAAL,CAAWC,OAAX,GAAqB,MAArB;MACAH,iBAAiB,CAACE,KAAlB,CAAwBC,OAAxB,GAAkC,MAAlC;MACAJ,iBAAiB,CAACG,KAAlB,CAAwBC,OAAxB,GAAkC,OAAlC;MACAJ,iBAAiB,CAACF,aAAlB,CAAgC,OAAhC,EAAyCO,KAAzC;MACAL,iBAAiB,CAACF,aAAlB,CAAgC,GAAhC,EAAqCI,gBAArC,CAAsD,OAAtD,EAA+D,UAAUI,KAAV,EAAiB;QAC5EN,iBAAiB,CAACG,KAAlB,CAAwBC,OAAxB,GAAkC,MAAlC;QACAP,YAAY,CAACM,KAAb,CAAmBC,OAAnB,GAA6B,OAA7B;QACAL,iBAAiB,CAACI,KAAlB,CAAwBC,OAAxB,GAAkC,OAAlC;QACAH,iBAAiB,CAACE,KAAlB,CAAwBC,OAAxB,GAAkC,OAAlC;MACH,CALD;MAOAJ,iBAAiB,CAACF,aAAlB,CAAgC,QAAhC,EAA0CI,gBAA1C,CAA2D,OAA3D,EAAoE,UAAUI,KAAV,EAAiB;QACjFA,KAAK,CAACC,wBAAN;QACA,MAAMC,KAAK,GAAGR,iBAAiB,CAACF,aAAlB,CAAgC,OAAhC,EAAyCW,KAAvD;;QACA,IAAI,CAACD,KAAL,EAAY;UACRE,KAAK,CAAC,gCAAD,CAAL;QACH,CAFD,MAEO;UACH,MAAMC,IAAI,GAAG;YAACH,KAAD;YAAQI,SAAS,EAAE,MAAnB;YAA2BC,WAAW,EAAE;UAAxC,CAAb;UACArB,EAAE,CAACsB,QAAH,CAAY;YACRC,IAAI,EAAE,MAAM3B,aAAN,GAAsB,OADpB;YAER4B,MAAM,EAAE,MAFA;YAGRL;UAHQ,CAAZ,EAIGM,IAJH,CAISC,GAAD,IAAS;YACT,IAAIA,GAAG,CAACC,MAAJ,IAAcD,GAAG,CAACC,MAAJ,KAAe,SAAjC,EAA4C;cACxCnB,iBAAiB,CAACG,KAAlB,CAAwBC,OAAxB,GAAkC,MAAlC;cACAP,YAAY,CAACM,KAAb,CAAmBC,OAAnB,GAA6B,OAA7B;cACAL,iBAAiB,CAACI,KAAlB,CAAwBC,OAAxB,GAAkC,OAAlC;cACAH,iBAAiB,CAACE,KAAlB,CAAwBC,OAAxB,GAAkC,OAAlC;cACA,MAAMgB,iBAAiB,GAAGvB,YAAY,CAACC,aAAb,CAA2B,0BAA3B,EAAuDuB,SAAjF;cACAD,iBAAiB,CAACE,SAAlB,CAA4B;gBAACb,KAAK,EAAES,GAAG,CAACP,IAAJ,CAASY,EAAjB;gBAAqBC,IAAI,EAAEN,GAAG,CAACP,IAAJ,CAASH;cAApC,CAA5B;cACAY,iBAAiB,CAACK,QAAlB,CAA2B,CAACP,GAAG,CAACP,IAAJ,CAASY,EAAV,CAA3B;cACAtB,iBAAiB,CAACH,aAAlB,CAAgC,YAAhC,EAA8C4B,YAA9C,CAA2D,MAA3D,EAAmE,mBAAmBR,GAAG,CAACP,IAAJ,CAASY,EAA5B,GAAiC,cAApG;cACAtB,iBAAiB,CAACH,aAAlB,CAAgC,YAAhC,EAA8C4B,YAA9C,CAA2D,MAA3D,EAAmErC,uBAAuB,CAACsC,OAAxB,GAAkC,WAAlC,GAAgDT,GAAG,CAACP,IAAJ,CAASY,EAA5H;YACH;UACJ,CAhBL,EAiBEK,KAjBF,CAiBSC,GAAD,IAAS;YACbC,OAAO,CAACC,GAAR,CAAYF,GAAZ;UACH,CAnBD,EAmBGG,OAnBH,CAmBW,MAAM,CAChB,CApBD;QAqBH;MACJ,CA7BD;MA8BAhC,iBAAiB,CAACF,aAAlB,CAAgC,GAAhC,EAAqCI,gBAArC,CAAsD,OAAtD,EAA+D,UAAUI,KAAV,EAAiB;QAC5EA,KAAK,CAAC2B,cAAN;QACAjC,iBAAiB,CAACG,KAAlB,CAAwBC,OAAxB,GAAkC,MAAlC;QACAP,YAAY,CAACM,KAAb,CAAmBC,OAAnB,GAA6B,OAA7B;QACAL,iBAAiB,CAACI,KAAlB,CAAwBC,OAAxB,GAAkC,OAAlC;QACAH,iBAAiB,CAACE,KAAlB,CAAwBC,OAAxB,GAAkC,OAAlC;MACH,CAND;IAOH,CAlDD;IAoDA,MAAM8B,UAAU,GAAGrC,YAAY,CAACC,aAAb,CAA2B,QAA3B,CAAnB;;IAEA,IAAGoC,UAAH,EAAc;MACVA,UAAU,CAAChC,gBAAX,CAA4B,QAA5B,EAAsC,YAAY;QAC9C,MAAMO,KAAK,GAAG,KAAKA,KAAnB;;QACA,IAAGA,KAAH,EAAS;UACL,MAAM0B,YAAY,GAAGlC,iBAAiB,CAACH,aAAlB,CAAgC,YAAhC,CAArB;UACA,MAAMsC,YAAY,GAAGnC,iBAAiB,CAACH,aAAlB,CAAgC,YAAhC,CAArB;UACA,IAAIuC,WAAW,GAAG,mBAAmB5B,KAAnB,GAA2B,cAA7C;UACA,IAAI6B,WAAW,GAAGjD,uBAAuB,CAACsC,OAAxB,GAAkC,WAAlC,GAAgDlB,KAAlE;;UACA,IAAG0B,YAAY,IAAIC,YAAnB,EAAgC;YAC5BD,YAAY,CAACT,YAAb,CAA0B,MAA1B,EAAkCW,WAAlC;YACAD,YAAY,CAACV,YAAb,CAA0B,MAA1B,EAAkCY,WAAlC;UACH,CAHD,MAGK;YACDrC,iBAAiB,CAACsC,SAAlB,GAAgC,8BAA6BF,WAAY,oBAA1C,GAA+D9C,EAAE,CAAC,WAAD,EAAc,WAAd,CAAjE,GAA6F;AACpJ,qDAAqD+C,WAAY,oBADV,GAC8B/C,EAAE,CAAC,WAAD,EAAc,WAAd,CADhC,GAC4D,MAD3F;UAEH;QAEJ,CAbD,MAaK;UACDU,iBAAiB,CAACsC,SAAlB,GAA8B,EAA9B;QACH;MACJ,CAlBD;IAmBH;EACJ;AACJ,CA7FD;;AA+FA,iEAAevD,qBAAf;;;;;;;;;;;;;;;AC/FA,MAAMwD,+BAA+B,GAAG,MAAM;EAC7C,MAAMC,iBAAiB,GAAGvD,QAAQ,CAACY,aAAT,CAAwB,iBAAxB,CAA1B;;EAEA,IAAK,CAAE2C,iBAAP,EAA2B;IAC1B;EACA;;EAEDA,iBAAiB,CAAC3C,aAAlB,CAAiC,QAAjC,EAA4CI,gBAA5C,CAA8D,OAA9D,EAAuE,YAAW;IACjFuC,iBAAiB,CAACC,MAAlB;EACA,CAFD;AAGA,CAVD;;AAYA,iEAAeF,+BAAf;;;;;;;;;;;;;;;;;ACZA;;AAEA,MAAMI,kBAAkB,GAAG,MAAM;EAChC,MAAMC,YAAY,GAAG3D,QAAQ,CAACC,gBAAT,CAA2B,0BAA3B,CAArB;;EACA,IAAK,CAAE0D,YAAP,EAAsB;IACrB;EACA;;EACD,KAAM,IAAInD,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGmD,YAAY,CAAClD,MAAlC,EAA0CD,CAAC,EAA3C,EAAgD;IAC/C,MAAMoD,WAAW,GAAGD,YAAY,CAAEnD,CAAF,CAAhC;IACA,IAAIqD,QAAQ,GAAG;MACdC,UAAU,EAAC;IADG,CAAf;;IAGA,IAAKF,WAAW,CAACG,QAAjB,EAA4B;MAC3B,IAAKC,OAAO,GAAG,CAAE,qBAAF,EAAyB,eAAzB,EAA0C,cAA1C,EAA0D,iBAA1D,CAAf;MACAH,QAAQ,GAAG,EAAC,GAAGA,QAAJ;QAAcG;MAAd,CAAX;IACA,CAHD,MAGO;MACN,IAAIA,OAAO,GAAE,CAAE,cAAF,CAAb;MACAH,QAAQ,GAAG,EAAC,GAAGA,QAAJ;QAAcG;MAAd,CAAX;IACA;;IAED,IAAIP,mDAAJ,CAAeG,WAAf,EAA4BC,QAA5B;EACA;AACD,CApBD;;AAsBA,iEAAeH,kBAAf;;;;;;;;;;ACxBA;AACA;AACA;AACA;;AAEA;AACA,CAAC,KAA4D;AAC7D,CAAC,CACwG;AACzG,CAAC,uBAAuB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB,GAAG,yBAAyB;AACjE;AACA;AACA,WAAW,OAAO,KAAK,SAAS,KAAK,SAAS;AAC9C;AACA,gBAAgB,cAAc;AAC9B;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,UAAU;AACV,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,GAAG,GAAG,IAAI,IAAI,MAAM;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI,GAAG;;AAEP;;AAEA,mBAAmB,wBAAwB;AAC3C;;AAEA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA,yFAAyF;AACzF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,iBAAiB;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,GAAG;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B,uEAAuE;;;AAGvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;;AAEA;;AAEA,8CAA8C;;AAE9C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;;;AAGA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,+DAA+D;AAC/D,sDAAsD;AACtD,gDAAgD;AAChD,qDAAqD;AACrD,4DAA4D;AAC5D,qDAAqD;AACrD,gDAAgD;AAChD,2DAA2D;AAC3D,qDAAqD;AACrD,gDAAgD;AAChD,wDAAwD;AACxD,kDAAkD;AAClD,gDAAgD;AAChD,wDAAwD;AACxD,wDAAwD;AACxD,mDAAmD;AACnD,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,sBAAsB,sBAAsB,wBAAwB;AAC7G;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;;;AAGN;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,eAAe;;AAEjD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B;;AAE7B;AACA,wDAAwD;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA,MAAM,GAAG;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uEAAuE;;AAEvE;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,QAAQ;AACR;AACA;AACA,wCAAwC;AACxC,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,QAAQ;AACR,OAAO;;;AAGP;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM,GAAG;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;;AAEA;AACA;AACA,MAAM,GAAG;;AAET,8DAA8D;;AAE9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA,gCAAgC;AAChC,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,sBAAsB;AACtB;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA,4FAA4F;AAC5F,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,gDAAgD;;AAEhD,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA,OAAO;;;AAGP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B,WAAW;AACX,8BAA8B;AAC9B,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,UAAU;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,OAAO;AACP,gCAAgC;AAChC,OAAO;;;AAGP;AACA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,wDAAwD;;AAExD;AACA;AACA;;AAEA;AACA;;AAEA,sDAAsD,OAAO;AAC7D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA,qCAAqC;;AAErC;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;;;AAGP;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;;AAEA;AACA,QAAQ;;;AAGR;AACA,gCAAgC;AAChC,OAAO;AACP,oCAAoC;AACpC,OAAO;AACP;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA,qCAAqC;;AAErC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;;AAGP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE,kBAAkB;AAC1F;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;;AAGA;AACA;AACA,WAAW;;;AAGX;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,uEAAuE;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;;AAGA;AACA;AACA;;AAEA,mCAAmC;AACnC;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;;AAGT;AACA;AACA,QAAQ,GAAG;;AAEX;AACA,4CAA4C;AAC5C,SAAS;AACT;AACA;AACA;;AAEA;AACA,yEAAyE,kBAAkB;AAC3F;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,mDAAmD;;AAEnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,2DAA2D;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;;AAEX,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C,SAAS;;AAET,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA,UAAU;AACV,SAAS;AACT;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,QAAQ,GAAG;;AAEX;AACA;AACA;AACA;AACA,UAAU;AACV,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU,GAAG;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,MAAM;AACN,MAAM;;;AAGN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,GAAG;;AAEP;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA,IAAI,GAAG;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,GAAG;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe,WAAW,WAAW,SAAS;AAC3E;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qNAAqN;AACrN;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,IAAI;AACJ;AACA,kCAAkC;;AAElC;;AAEA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,OAAO;AACP;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA,gEAAgE;;AAEhE;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA,MAAM,GAAG;;AAET;AACA;AACA,MAAM,GAAG;;AAET;AACA;AACA;AACA;AACA,MAAM;AACN,gEAAgE;;AAEhE;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;;AAEA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc,eAAe,YAAY,WAAW,iBAAiB;AACzH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,IAAI,gBAAgB;;AAEpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA,IAAI;AACJ;AACA,IAAI,GAAG;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;;AAGN;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA,MAAM;AACN;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,IAAI,GAAG;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,GAAG;;AAEP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,IAAI,GAAG;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;AAER;AACA,qDAAqD;;AAErD;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,IAAI,GAAG;;AAEP;AACA;AACA,+CAA+C;;AAE/C,4CAA4C;AAC5C;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM,yBAAyB;;AAE/B;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;AACD,gCAAgC;AAChC;;;;;;;UCj3JA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNA;AACA;AACA;AAGA1D,QAAQ,CAACgB,gBAAT,CAA2B,kBAA3B,EAAiDI,KAAF,IAAa;EAC3DkC,2EAA+B;EAC/BxD,oEAAqB;EACrB4D,8DAAkB;AAClB,CAJD,E","sources":["webpack://realpress/./assets/src/js/admin/mixins/wp-dropdown-page.js","webpack://realpress/./assets/src/js/admin/setup/quick-setup-notification.js","webpack://realpress/./assets/src/js/mixins/tom-select.js","webpack://realpress/./node_modules/tom-select/dist/js/tom-select.complete.js","webpack://realpress/webpack/bootstrap","webpack://realpress/webpack/runtime/compat get default export","webpack://realpress/webpack/runtime/define property getters","webpack://realpress/webpack/runtime/hasOwnProperty shorthand","webpack://realpress/webpack/runtime/make namespace object","webpack://realpress/./assets/src/js/admin/realpress-global.tsx"],"sourcesContent":["const realpressDropDownPage = () => {\n    const dropdownWrapperNodes = document.querySelectorAll('.realpress-wp-dropdown-page-wrapper');\n    const restNamespace = REALPRESS_GLOBAL_OBJECT.rest_namespace || '';\n\n    if (!dropdownWrapperNodes) {\n        return;\n    }\n    const {__} = wp.i18n;\n    for (let i = 0; i < dropdownWrapperNodes.length; i++) {\n        const dropdownWrapperNode = dropdownWrapperNodes[i];\n        const dropDownNode = dropdownWrapperNode.querySelector('.realpress-wp-dropdown-page-content .realpress-dropdown');\n        const createPageBtnNode = dropdownWrapperNode.querySelector('.realpress-wp-dropdown-page-content > button');\n        if (!createPageBtnNode) {\n            continue;\n        }\n        const addPageInlineNode = dropdownWrapperNode.querySelector('.realpress-quick-add-page-inline');\n        const addPageActionNode = dropdownWrapperNode.querySelector('.realpress-quick-add-page-actions');\n        createPageBtnNode.addEventListener('click', function () {\n            dropDownNode.style.display = 'none';\n            this.style.display = 'none';\n            addPageActionNode.style.display = 'none';\n            addPageInlineNode.style.display = 'block';\n            addPageInlineNode.querySelector('input').focus();\n            addPageInlineNode.querySelector('a').addEventListener('click', function (event) {\n                addPageInlineNode.style.display = 'none';\n                dropDownNode.style.display = 'block';\n                createPageBtnNode.style.display = 'block';\n                addPageActionNode.style.display = 'block';\n            });\n\n            addPageInlineNode.querySelector('button').addEventListener('click', function (event) {\n                event.stopImmediatePropagation();\n                const title = addPageInlineNode.querySelector('input').value;\n                if (!title) {\n                    alert('Please enter the title of page');\n                } else {\n                    const data = {title, post_type: 'page', post_status: 'publish'};\n                    wp.apiFetch({\n                        path: '/' + restNamespace + '/page',\n                        method: 'POST',\n                        data,\n                    }).then((res) => {\n                            if (res.status && res.status === 'success') {\n                                addPageInlineNode.style.display = 'none';\n                                dropDownNode.style.display = 'block';\n                                createPageBtnNode.style.display = 'block';\n                                addPageActionNode.style.display = 'block';\n                                const selectControlNode = dropDownNode.querySelector('select.realpress-select2').tomselect;\n                                selectControlNode.addOption({value: res.data.id, text: res.data.title});\n                                selectControlNode.setValue([res.data.id]);\n                                addPageActionNode.querySelector('.edit-page').setAttribute('href', 'post.php?post=' + res.data.id + '&action=edit');\n                                addPageActionNode.querySelector('.view-page').setAttribute('href', REALPRESS_GLOBAL_OBJECT.siteurl + '?page_id=' + res.data.id);\n                            }\n                        }\n                    ).catch((err) => {\n                        console.log(err);\n                    }).finally(() => {\n                    });\n                }\n            });\n            addPageInlineNode.querySelector('a').addEventListener('click', function (event) {\n                event.preventDefault();\n                addPageInlineNode.style.display = 'none';\n                dropDownNode.style.display = 'block';\n                createPageBtnNode.style.display = 'block';\n                addPageActionNode.style.display = 'block';\n            });\n        });\n\n        const selectNode = dropDownNode.querySelector('select');\n\n        if(selectNode){\n            selectNode.addEventListener('change', function () {\n                const value = this.value;\n                if(value){\n                    const editPageNode = addPageActionNode.querySelector('.edit-page');\n                    const viewPageNode = addPageActionNode.querySelector('.view-page');\n                    let editPageUrl = 'post.php?post=' + value + '&action=edit';\n                    let viewPageUrl = REALPRESS_GLOBAL_OBJECT.siteurl + '?page_id=' + value\n                    if(editPageNode && viewPageNode){\n                        editPageNode.setAttribute('href', editPageUrl);\n                        viewPageNode.setAttribute('href', viewPageUrl);\n                    }else{\n                        addPageActionNode.innerHTML =  `<a class=\"edit-page\" href=\"${editPageUrl}\" target=\"_blank\">`+ __('Edit page', 'realpress')+`</a> |\n                        <a class=\"view-page\" href=\"${viewPageUrl}\" target=\"_blank\">`+__('View page', 'realpress')+`</a>`;\n                    }\n\n                }else{\n                    addPageActionNode.innerHTML = '';\n                }\n            });\n        }\n    }\n}\n\nexport default realpressDropDownPage;\n","const realpressQuickSetupNotification = () => {\n\tconst notificactionNode = document.querySelector( '#notice-install' );\n\n\tif ( ! notificactionNode ) {\n\t\treturn;\n\t}\n\n\tnotificactionNode.querySelector( 'button' ).addEventListener( 'click', function() {\n\t\tnotificactionNode.remove();\n\t} );\n};\n\nexport default realpressQuickSetupNotification;\n","import TomSelect from 'tom-select';\n\nconst realpressTomSelect = () => {\n\tconst select2Nodes = document.querySelectorAll( 'select.realpress-select2' );\n\tif ( ! select2Nodes ) {\n\t\treturn;\n\t}\n\tfor ( let i = 0; i < select2Nodes.length; i++ ) {\n\t\tconst select2Node = select2Nodes[ i ];\n\t\tlet settings = {\n\t\t\tmaxOptions:null,\n\t\t};\n\t\tif ( select2Node.multiple ) {\n\t\t\tlet  plugins=  [ 'no_backspace_delete', 'remove_button', 'clear_button', 'change_listener' ];\n\t\t\tsettings = {...settings, plugins};\n\t\t} else {\n\t\t\tlet plugins= [ 'clear_button' ];\n\t\t\tsettings = {...settings, plugins};\n\t\t}\n\n\t\tnew TomSelect( select2Node, settings );\n\t}\n};\n\nexport default realpressTomSelect;\n","/**\n* Tom Select v2.1.0\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n*/\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.TomSelect = factory());\n})(this, (function () { 'use strict';\n\n\t/**\n\t * MicroEvent - to make any js object an event emitter\n\t *\n\t * - pure javascript - server compatible, browser compatible\n\t * - dont rely on the browser doms\n\t * - super simple - you get it immediatly, no mistery, no magic involved\n\t *\n\t * @author Jerome Etienne (https://github.com/jeromeetienne)\n\t */\n\n\t/**\n\t * Execute callback for each event in space separated list of event names\n\t *\n\t */\n\tfunction forEvents(events, callback) {\n\t  events.split(/\\s+/).forEach(event => {\n\t    callback(event);\n\t  });\n\t}\n\n\tclass MicroEvent {\n\t  constructor() {\n\t    this._events = void 0;\n\t    this._events = {};\n\t  }\n\n\t  on(events, fct) {\n\t    forEvents(events, event => {\n\t      this._events[event] = this._events[event] || [];\n\n\t      this._events[event].push(fct);\n\t    });\n\t  }\n\n\t  off(events, fct) {\n\t    var n = arguments.length;\n\n\t    if (n === 0) {\n\t      this._events = {};\n\t      return;\n\t    }\n\n\t    forEvents(events, event => {\n\t      if (n === 1) return delete this._events[event];\n\t      if (event in this._events === false) return;\n\n\t      this._events[event].splice(this._events[event].indexOf(fct), 1);\n\t    });\n\t  }\n\n\t  trigger(events, ...args) {\n\t    var self = this;\n\t    forEvents(events, event => {\n\t      if (event in self._events === false) return;\n\n\t      for (let fct of self._events[event]) {\n\t        fct.apply(self, args);\n\t      }\n\t    });\n\t  }\n\n\t}\n\n\t/**\n\t * microplugin.js\n\t * Copyright (c) 2013 Brian Reavis & contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t * @author Brian Reavis <brian@thirdroute.com>\n\t */\n\tfunction MicroPlugin(Interface) {\n\t  Interface.plugins = {};\n\t  return class extends Interface {\n\t    constructor(...args) {\n\t      super(...args);\n\t      this.plugins = {\n\t        names: [],\n\t        settings: {},\n\t        requested: {},\n\t        loaded: {}\n\t      };\n\t    }\n\n\t    /**\n\t     * Registers a plugin.\n\t     *\n\t     * @param {function} fn\n\t     */\n\t    static define(name, fn) {\n\t      Interface.plugins[name] = {\n\t        'name': name,\n\t        'fn': fn\n\t      };\n\t    }\n\t    /**\n\t     * Initializes the listed plugins (with options).\n\t     * Acceptable formats:\n\t     *\n\t     * List (without options):\n\t     *   ['a', 'b', 'c']\n\t     *\n\t     * List (with options):\n\t     *   [{'name': 'a', options: {}}, {'name': 'b', options: {}}]\n\t     *\n\t     * Hash (with options):\n\t     *   {'a': { ... }, 'b': { ... }, 'c': { ... }}\n\t     *\n\t     * @param {array|object} plugins\n\t     */\n\n\n\t    initializePlugins(plugins) {\n\t      var key, name;\n\t      const self = this;\n\t      const queue = [];\n\n\t      if (Array.isArray(plugins)) {\n\t        plugins.forEach(plugin => {\n\t          if (typeof plugin === 'string') {\n\t            queue.push(plugin);\n\t          } else {\n\t            self.plugins.settings[plugin.name] = plugin.options;\n\t            queue.push(plugin.name);\n\t          }\n\t        });\n\t      } else if (plugins) {\n\t        for (key in plugins) {\n\t          if (plugins.hasOwnProperty(key)) {\n\t            self.plugins.settings[key] = plugins[key];\n\t            queue.push(key);\n\t          }\n\t        }\n\t      }\n\n\t      while (name = queue.shift()) {\n\t        self.require(name);\n\t      }\n\t    }\n\n\t    loadPlugin(name) {\n\t      var self = this;\n\t      var plugins = self.plugins;\n\t      var plugin = Interface.plugins[name];\n\n\t      if (!Interface.plugins.hasOwnProperty(name)) {\n\t        throw new Error('Unable to find \"' + name + '\" plugin');\n\t      }\n\n\t      plugins.requested[name] = true;\n\t      plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);\n\t      plugins.names.push(name);\n\t    }\n\t    /**\n\t     * Initializes a plugin.\n\t     *\n\t     */\n\n\n\t    require(name) {\n\t      var self = this;\n\t      var plugins = self.plugins;\n\n\t      if (!self.plugins.loaded.hasOwnProperty(name)) {\n\t        if (plugins.requested[name]) {\n\t          throw new Error('Plugin has circular dependency (\"' + name + '\")');\n\t        }\n\n\t        self.loadPlugin(name);\n\t      }\n\n\t      return plugins.loaded[name];\n\t    }\n\n\t  };\n\t}\n\n\t// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\n\t// https://github.com/andrewrk/node-diacritics/blob/master/index.js\n\tvar latin_pat;\n\tconst accent_pat = '[\\u0300-\\u036F\\u{b7}\\u{2be}]'; // \\u{2bc}\n\n\tconst accent_reg = new RegExp(accent_pat, 'gu');\n\tvar diacritic_patterns;\n\tconst latin_convert = {\n\t  'æ': 'ae',\n\t  'ⱥ': 'a',\n\t  'ø': 'o'\n\t};\n\tconst convert_pat = new RegExp(Object.keys(latin_convert).join('|'), 'gu');\n\tconst code_points = [[0, 65535]];\n\t/**\n\t * Remove accents\n\t * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n\t *\n\t */\n\n\tconst asciifold = str => {\n\t  return str.normalize('NFKD').replace(accent_reg, '').toLowerCase().replace(convert_pat, function (foreignletter) {\n\t    return latin_convert[foreignletter];\n\t  });\n\t};\n\t/**\n\t * Convert array of strings to a regular expression\n\t *\tex ['ab','a'] => (?:ab|a)\n\t * \tex ['a','b'] => [ab]\n\t *\n\t */\n\n\tconst arrayToPattern = (chars, glue = '|') => {\n\t  if (chars.length == 1) {\n\t    return chars[0];\n\t  }\n\n\t  var longest = 1;\n\t  chars.forEach(a => {\n\t    longest = Math.max(longest, a.length);\n\t  });\n\n\t  if (longest == 1) {\n\t    return '[' + chars.join('') + ']';\n\t  }\n\n\t  return '(?:' + chars.join(glue) + ')';\n\t};\n\tconst escapeToPattern = chars => {\n\t  const escaped = chars.map(diacritic => escape_regex(diacritic));\n\t  return arrayToPattern(escaped);\n\t};\n\t/**\n\t * Get all possible combinations of substrings that add up to the given string\n\t * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string\n\t *\n\t */\n\n\tconst allSubstrings = input => {\n\t  if (input.length === 1) return [[input]];\n\t  var result = [];\n\t  allSubstrings(input.substring(1)).forEach(function (subresult) {\n\t    var tmp = subresult.slice(0);\n\t    tmp[0] = input.charAt(0) + tmp[0];\n\t    result.push(tmp);\n\t    tmp = subresult.slice(0);\n\t    tmp.unshift(input.charAt(0));\n\t    result.push(tmp);\n\t  });\n\t  return result;\n\t};\n\t/**\n\t * Generate a list of diacritics from the list of code points\n\t *\n\t */\n\n\tconst generateDiacritics = code_points => {\n\t  var diacritics = {};\n\t  code_points.forEach(code_range => {\n\t    for (let i = code_range[0]; i <= code_range[1]; i++) {\n\t      let diacritic = String.fromCharCode(i);\n\t      let latin = asciifold(diacritic);\n\n\t      if (latin == diacritic.toLowerCase()) {\n\t        continue;\n\t      } // skip when latin is a string longer than 3 characters long\n\t      // bc the resulting regex patterns will be long\n\t      // eg:\n\t      // latin صلى الله عليه وسلم length 18 code point 65018\n\t      // latin جل جلاله length 8 code point 65019\n\n\n\t      if (latin.length > 3) {\n\t        continue;\n\t      }\n\n\t      if (!(latin in diacritics)) {\n\t        diacritics[latin] = [latin];\n\t      }\n\n\t      var patt = new RegExp(escapeToPattern(diacritics[latin]), 'iu');\n\n\t      if (diacritic.match(patt)) {\n\t        continue;\n\t      }\n\n\t      diacritics[latin].push(diacritic);\n\t    }\n\t  }); // filter out if there's only one character in the list\n\n\t  let latin_chars = Object.keys(diacritics);\n\n\t  for (let i = 0; i < latin_chars.length; i++) {\n\t    const latin = latin_chars[i];\n\n\t    if (diacritics[latin].length < 2) {\n\t      delete diacritics[latin];\n\t    }\n\t  } // latin character pattern\n\t  // match longer substrings first\n\n\n\t  latin_chars = Object.keys(diacritics).sort((a, b) => b.length - a.length);\n\t  latin_pat = new RegExp('(' + escapeToPattern(latin_chars) + accent_pat + '*)', 'gu'); // build diacritic patterns\n\t  // ae needs:\n\t  //\t(?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))\n\n\t  var diacritic_patterns = {};\n\t  latin_chars.sort((a, b) => a.length - b.length).forEach(latin => {\n\t    var substrings = allSubstrings(latin);\n\t    var pattern = substrings.map(sub_pat => {\n\t      sub_pat = sub_pat.map(l => {\n\t        if (diacritics.hasOwnProperty(l)) {\n\t          return escapeToPattern(diacritics[l]);\n\t        }\n\n\t        return l;\n\t      });\n\t      return arrayToPattern(sub_pat, '');\n\t    });\n\t    diacritic_patterns[latin] = arrayToPattern(pattern);\n\t  });\n\t  return diacritic_patterns;\n\t};\n\t/**\n\t * Expand a regular expression pattern to include diacritics\n\t * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n\t *\n\t */\n\n\tconst diacriticRegexPoints = regex => {\n\t  if (diacritic_patterns === undefined) {\n\t    diacritic_patterns = generateDiacritics(code_points);\n\t  }\n\n\t  const decomposed = regex.normalize('NFKD').toLowerCase();\n\t  return decomposed.split(latin_pat).map(part => {\n\t    // \"ﬄ\" or \"ffl\"\n\t    const no_accent = asciifold(part);\n\n\t    if (no_accent == '') {\n\t      return '';\n\t    }\n\n\t    if (diacritic_patterns.hasOwnProperty(no_accent)) {\n\t      return diacritic_patterns[no_accent];\n\t    }\n\n\t    return part;\n\t  }).join('');\n\t};\n\n\t// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\n\n\t/**\n\t * A property getter resolving dot-notation\n\t * @param  {Object}  obj     The root object to fetch property on\n\t * @param  {String}  name    The optionally dotted property name to fetch\n\t * @return {Object}          The resolved property value\n\t */\n\tconst getAttr = (obj, name) => {\n\t  if (!obj) return;\n\t  return obj[name];\n\t};\n\t/**\n\t * A property getter resolving dot-notation\n\t * @param  {Object}  obj     The root object to fetch property on\n\t * @param  {String}  name    The optionally dotted property name to fetch\n\t * @return {Object}          The resolved property value\n\t */\n\n\tconst getAttrNesting = (obj, name) => {\n\t  if (!obj) return;\n\t  var part,\n\t      names = name.split(\".\");\n\n\t  while ((part = names.shift()) && (obj = obj[part]));\n\n\t  return obj;\n\t};\n\t/**\n\t * Calculates how close of a match the\n\t * given value is against a search token.\n\t *\n\t */\n\n\tconst scoreValue = (value, token, weight) => {\n\t  var score, pos;\n\t  if (!value) return 0;\n\t  value = value + '';\n\t  pos = value.search(token.regex);\n\t  if (pos === -1) return 0;\n\t  score = token.string.length / value.length;\n\t  if (pos === 0) score += 0.5;\n\t  return score * weight;\n\t};\n\t/**\n\t *\n\t * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error\n\t */\n\n\tconst escape_regex = str => {\n\t  return (str + '').replace(/([\\$\\(-\\+\\.\\?\\[-\\^\\{-\\}])/g, '\\\\$1');\n\t};\n\t/**\n\t * Cast object property to an array if it exists and has a value\n\t *\n\t */\n\n\tconst propToArray = (obj, key) => {\n\t  var value = obj[key];\n\t  if (typeof value == 'function') return value;\n\n\t  if (value && !Array.isArray(value)) {\n\t    obj[key] = [value];\n\t  }\n\t};\n\t/**\n\t * Iterates over arrays and hashes.\n\t *\n\t * ```\n\t * iterate(this.items, function(item, id) {\n\t *    // invoked for each item\n\t * });\n\t * ```\n\t *\n\t */\n\n\tconst iterate = (object, callback) => {\n\t  if (Array.isArray(object)) {\n\t    object.forEach(callback);\n\t  } else {\n\t    for (var key in object) {\n\t      if (object.hasOwnProperty(key)) {\n\t        callback(object[key], key);\n\t      }\n\t    }\n\t  }\n\t};\n\tconst cmp = (a, b) => {\n\t  if (typeof a === 'number' && typeof b === 'number') {\n\t    return a > b ? 1 : a < b ? -1 : 0;\n\t  }\n\n\t  a = asciifold(a + '').toLowerCase();\n\t  b = asciifold(b + '').toLowerCase();\n\t  if (a > b) return 1;\n\t  if (b > a) return -1;\n\t  return 0;\n\t};\n\n\t/**\n\t * sifter.js\n\t * Copyright (c) 2013–2020 Brian Reavis & contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t * @author Brian Reavis <brian@thirdroute.com>\n\t */\n\n\tclass Sifter {\n\t  // []|{};\n\n\t  /**\n\t   * Textually searches arrays and hashes of objects\n\t   * by property (or multiple properties). Designed\n\t   * specifically for autocomplete.\n\t   *\n\t   */\n\t  constructor(items, settings) {\n\t    this.items = void 0;\n\t    this.settings = void 0;\n\t    this.items = items;\n\t    this.settings = settings || {\n\t      diacritics: true\n\t    };\n\t  }\n\n\t  /**\n\t   * Splits a search string into an array of individual\n\t   * regexps to be used to match results.\n\t   *\n\t   */\n\t  tokenize(query, respect_word_boundaries, weights) {\n\t    if (!query || !query.length) return [];\n\t    const tokens = [];\n\t    const words = query.split(/\\s+/);\n\t    var field_regex;\n\n\t    if (weights) {\n\t      field_regex = new RegExp('^(' + Object.keys(weights).map(escape_regex).join('|') + ')\\:(.*)$');\n\t    }\n\n\t    words.forEach(word => {\n\t      let field_match;\n\t      let field = null;\n\t      let regex = null; // look for \"field:query\" tokens\n\n\t      if (field_regex && (field_match = word.match(field_regex))) {\n\t        field = field_match[1];\n\t        word = field_match[2];\n\t      }\n\n\t      if (word.length > 0) {\n\t        if (this.settings.diacritics) {\n\t          regex = diacriticRegexPoints(word);\n\t        } else {\n\t          regex = escape_regex(word);\n\t        }\n\n\t        if (respect_word_boundaries) regex = \"\\\\b\" + regex;\n\t      }\n\n\t      tokens.push({\n\t        string: word,\n\t        regex: regex ? new RegExp(regex, 'iu') : null,\n\t        field: field\n\t      });\n\t    });\n\t    return tokens;\n\t  }\n\n\t  /**\n\t   * Returns a function to be used to score individual results.\n\t   *\n\t   * Good matches will have a higher score than poor matches.\n\t   * If an item is not a match, 0 will be returned by the function.\n\t   *\n\t   * @returns {function}\n\t   */\n\t  getScoreFunction(query, options) {\n\t    var search = this.prepareSearch(query, options);\n\t    return this._getScoreFunction(search);\n\t  }\n\n\t  _getScoreFunction(search) {\n\t    const tokens = search.tokens,\n\t          token_count = tokens.length;\n\n\t    if (!token_count) {\n\t      return function () {\n\t        return 0;\n\t      };\n\t    }\n\n\t    const fields = search.options.fields,\n\t          weights = search.weights,\n\t          field_count = fields.length,\n\t          getAttrFn = search.getAttrFn;\n\n\t    if (!field_count) {\n\t      return function () {\n\t        return 1;\n\t      };\n\t    }\n\t    /**\n\t     * Calculates the score of an object\n\t     * against the search query.\n\t     *\n\t     */\n\n\n\t    const scoreObject = function () {\n\t      if (field_count === 1) {\n\t        return function (token, data) {\n\t          const field = fields[0].field;\n\t          return scoreValue(getAttrFn(data, field), token, weights[field]);\n\t        };\n\t      }\n\n\t      return function (token, data) {\n\t        var sum = 0; // is the token specific to a field?\n\n\t        if (token.field) {\n\t          const value = getAttrFn(data, token.field);\n\n\t          if (!token.regex && value) {\n\t            sum += 1 / field_count;\n\t          } else {\n\t            sum += scoreValue(value, token, 1);\n\t          }\n\t        } else {\n\t          iterate(weights, (weight, field) => {\n\t            sum += scoreValue(getAttrFn(data, field), token, weight);\n\t          });\n\t        }\n\n\t        return sum / field_count;\n\t      };\n\t    }();\n\n\t    if (token_count === 1) {\n\t      return function (data) {\n\t        return scoreObject(tokens[0], data);\n\t      };\n\t    }\n\n\t    if (search.options.conjunction === 'and') {\n\t      return function (data) {\n\t        var i = 0,\n\t            score,\n\t            sum = 0;\n\n\t        for (; i < token_count; i++) {\n\t          score = scoreObject(tokens[i], data);\n\t          if (score <= 0) return 0;\n\t          sum += score;\n\t        }\n\n\t        return sum / token_count;\n\t      };\n\t    } else {\n\t      return function (data) {\n\t        var sum = 0;\n\t        iterate(tokens, token => {\n\t          sum += scoreObject(token, data);\n\t        });\n\t        return sum / token_count;\n\t      };\n\t    }\n\t  }\n\n\t  /**\n\t   * Returns a function that can be used to compare two\n\t   * results, for sorting purposes. If no sorting should\n\t   * be performed, `null` will be returned.\n\t   *\n\t   * @return function(a,b)\n\t   */\n\t  getSortFunction(query, options) {\n\t    var search = this.prepareSearch(query, options);\n\t    return this._getSortFunction(search);\n\t  }\n\n\t  _getSortFunction(search) {\n\t    var i, n, implicit_score;\n\t    const self = this,\n\t          options = search.options,\n\t          sort = !search.query && options.sort_empty ? options.sort_empty : options.sort,\n\t          sort_flds = [],\n\t          multipliers = [];\n\n\t    if (typeof sort == 'function') {\n\t      return sort.bind(this);\n\t    }\n\t    /**\n\t     * Fetches the specified sort field value\n\t     * from a search result item.\n\t     *\n\t     */\n\n\n\t    const get_field = function get_field(name, result) {\n\t      if (name === '$score') return result.score;\n\t      return search.getAttrFn(self.items[result.id], name);\n\t    }; // parse options\n\n\n\t    if (sort) {\n\t      for (i = 0, n = sort.length; i < n; i++) {\n\t        if (search.query || sort[i].field !== '$score') {\n\t          sort_flds.push(sort[i]);\n\t        }\n\t      }\n\t    } // the \"$score\" field is implied to be the primary\n\t    // sort field, unless it's manually specified\n\n\n\t    if (search.query) {\n\t      implicit_score = true;\n\n\t      for (i = 0, n = sort_flds.length; i < n; i++) {\n\t        if (sort_flds[i].field === '$score') {\n\t          implicit_score = false;\n\t          break;\n\t        }\n\t      }\n\n\t      if (implicit_score) {\n\t        sort_flds.unshift({\n\t          field: '$score',\n\t          direction: 'desc'\n\t        });\n\t      }\n\t    } else {\n\t      for (i = 0, n = sort_flds.length; i < n; i++) {\n\t        if (sort_flds[i].field === '$score') {\n\t          sort_flds.splice(i, 1);\n\t          break;\n\t        }\n\t      }\n\t    }\n\n\t    for (i = 0, n = sort_flds.length; i < n; i++) {\n\t      multipliers.push(sort_flds[i].direction === 'desc' ? -1 : 1);\n\t    } // build function\n\n\n\t    const sort_flds_count = sort_flds.length;\n\n\t    if (!sort_flds_count) {\n\t      return null;\n\t    } else if (sort_flds_count === 1) {\n\t      const sort_fld = sort_flds[0].field;\n\t      const multiplier = multipliers[0];\n\t      return function (a, b) {\n\t        return multiplier * cmp(get_field(sort_fld, a), get_field(sort_fld, b));\n\t      };\n\t    } else {\n\t      return function (a, b) {\n\t        var i, result, field;\n\n\t        for (i = 0; i < sort_flds_count; i++) {\n\t          field = sort_flds[i].field;\n\t          result = multipliers[i] * cmp(get_field(field, a), get_field(field, b));\n\t          if (result) return result;\n\t        }\n\n\t        return 0;\n\t      };\n\t    }\n\t  }\n\n\t  /**\n\t   * Parses a search query and returns an object\n\t   * with tokens and fields ready to be populated\n\t   * with results.\n\t   *\n\t   */\n\t  prepareSearch(query, optsUser) {\n\t    const weights = {};\n\t    var options = Object.assign({}, optsUser);\n\t    propToArray(options, 'sort');\n\t    propToArray(options, 'sort_empty'); // convert fields to new format\n\n\t    if (options.fields) {\n\t      propToArray(options, 'fields');\n\t      const fields = [];\n\t      options.fields.forEach(field => {\n\t        if (typeof field == 'string') {\n\t          field = {\n\t            field: field,\n\t            weight: 1\n\t          };\n\t        }\n\n\t        fields.push(field);\n\t        weights[field.field] = 'weight' in field ? field.weight : 1;\n\t      });\n\t      options.fields = fields;\n\t    }\n\n\t    return {\n\t      options: options,\n\t      query: query.toLowerCase().trim(),\n\t      tokens: this.tokenize(query, options.respect_word_boundaries, weights),\n\t      total: 0,\n\t      items: [],\n\t      weights: weights,\n\t      getAttrFn: options.nesting ? getAttrNesting : getAttr\n\t    };\n\t  }\n\n\t  /**\n\t   * Searches through all items and returns a sorted array of matches.\n\t   *\n\t   */\n\t  search(query, options) {\n\t    var self = this,\n\t        score,\n\t        search;\n\t    search = this.prepareSearch(query, options);\n\t    options = search.options;\n\t    query = search.query; // generate result scoring function\n\n\t    const fn_score = options.score || self._getScoreFunction(search); // perform search and sort\n\n\n\t    if (query.length) {\n\t      iterate(self.items, (item, id) => {\n\t        score = fn_score(item);\n\n\t        if (options.filter === false || score > 0) {\n\t          search.items.push({\n\t            'score': score,\n\t            'id': id\n\t          });\n\t        }\n\t      });\n\t    } else {\n\t      iterate(self.items, (_, id) => {\n\t        search.items.push({\n\t          'score': 1,\n\t          'id': id\n\t        });\n\t      });\n\t    }\n\n\t    const fn_sort = self._getSortFunction(search);\n\n\t    if (fn_sort) search.items.sort(fn_sort); // apply limits\n\n\t    search.total = search.items.length;\n\n\t    if (typeof options.limit === 'number') {\n\t      search.items = search.items.slice(0, options.limit);\n\t    }\n\n\t    return search;\n\t  }\n\n\t}\n\n\t/**\n\t * Return a dom element from either a dom query string, jQuery object, a dom element or html string\n\t * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518\n\t *\n\t * param query should be {}\n\t */\n\n\tconst getDom = query => {\n\t  if (query.jquery) {\n\t    return query[0];\n\t  }\n\n\t  if (query instanceof HTMLElement) {\n\t    return query;\n\t  }\n\n\t  if (isHtmlString(query)) {\n\t    let div = document.createElement('div');\n\t    div.innerHTML = query.trim(); // Never return a text node of whitespace as the result\n\n\t    return div.firstChild;\n\t  }\n\n\t  return document.querySelector(query);\n\t};\n\tconst isHtmlString = arg => {\n\t  if (typeof arg === 'string' && arg.indexOf('<') > -1) {\n\t    return true;\n\t  }\n\n\t  return false;\n\t};\n\tconst escapeQuery = query => {\n\t  return query.replace(/['\"\\\\]/g, '\\\\$&');\n\t};\n\t/**\n\t * Dispatch an event\n\t *\n\t */\n\n\tconst triggerEvent = (dom_el, event_name) => {\n\t  var event = document.createEvent('HTMLEvents');\n\t  event.initEvent(event_name, true, false);\n\t  dom_el.dispatchEvent(event);\n\t};\n\t/**\n\t * Apply CSS rules to a dom element\n\t *\n\t */\n\n\tconst applyCSS = (dom_el, css) => {\n\t  Object.assign(dom_el.style, css);\n\t};\n\t/**\n\t * Add css classes\n\t *\n\t */\n\n\tconst addClasses = (elmts, ...classes) => {\n\t  var norm_classes = classesArray(classes);\n\t  elmts = castAsArray(elmts);\n\t  elmts.map(el => {\n\t    norm_classes.map(cls => {\n\t      el.classList.add(cls);\n\t    });\n\t  });\n\t};\n\t/**\n\t * Remove css classes\n\t *\n\t */\n\n\tconst removeClasses = (elmts, ...classes) => {\n\t  var norm_classes = classesArray(classes);\n\t  elmts = castAsArray(elmts);\n\t  elmts.map(el => {\n\t    norm_classes.map(cls => {\n\t      el.classList.remove(cls);\n\t    });\n\t  });\n\t};\n\t/**\n\t * Return arguments\n\t *\n\t */\n\n\tconst classesArray = args => {\n\t  var classes = [];\n\t  iterate(args, _classes => {\n\t    if (typeof _classes === 'string') {\n\t      _classes = _classes.trim().split(/[\\11\\12\\14\\15\\40]/);\n\t    }\n\n\t    if (Array.isArray(_classes)) {\n\t      classes = classes.concat(_classes);\n\t    }\n\t  });\n\t  return classes.filter(Boolean);\n\t};\n\t/**\n\t * Create an array from arg if it's not already an array\n\t *\n\t */\n\n\tconst castAsArray = arg => {\n\t  if (!Array.isArray(arg)) {\n\t    arg = [arg];\n\t  }\n\n\t  return arg;\n\t};\n\t/**\n\t * Get the closest node to the evt.target matching the selector\n\t * Stops at wrapper\n\t *\n\t */\n\n\tconst parentMatch = (target, selector, wrapper) => {\n\t  if (wrapper && !wrapper.contains(target)) {\n\t    return;\n\t  }\n\n\t  while (target && target.matches) {\n\t    if (target.matches(selector)) {\n\t      return target;\n\t    }\n\n\t    target = target.parentNode;\n\t  }\n\t};\n\t/**\n\t * Get the first or last item from an array\n\t *\n\t * > 0 - right (last)\n\t * <= 0 - left (first)\n\t *\n\t */\n\n\tconst getTail = (list, direction = 0) => {\n\t  if (direction > 0) {\n\t    return list[list.length - 1];\n\t  }\n\n\t  return list[0];\n\t};\n\t/**\n\t * Return true if an object is empty\n\t *\n\t */\n\n\tconst isEmptyObject = obj => {\n\t  return Object.keys(obj).length === 0;\n\t};\n\t/**\n\t * Get the index of an element amongst sibling nodes of the same type\n\t *\n\t */\n\n\tconst nodeIndex = (el, amongst) => {\n\t  if (!el) return -1;\n\t  amongst = amongst || el.nodeName;\n\t  var i = 0;\n\n\t  while (el = el.previousElementSibling) {\n\t    if (el.matches(amongst)) {\n\t      i++;\n\t    }\n\t  }\n\n\t  return i;\n\t};\n\t/**\n\t * Set attributes of an element\n\t *\n\t */\n\n\tconst setAttr = (el, attrs) => {\n\t  iterate(attrs, (val, attr) => {\n\t    if (val == null) {\n\t      el.removeAttribute(attr);\n\t    } else {\n\t      el.setAttribute(attr, '' + val);\n\t    }\n\t  });\n\t};\n\t/**\n\t * Replace a node\n\t */\n\n\tconst replaceNode = (existing, replacement) => {\n\t  if (existing.parentNode) existing.parentNode.replaceChild(replacement, existing);\n\t};\n\n\t/**\n\t * highlight v3 | MIT license | Johann Burkard <jb@eaio.com>\n\t * Highlights arbitrary terms in a node.\n\t *\n\t * - Modified by Marshal <beatgates@gmail.com> 2011-6-24 (added regex)\n\t * - Modified by Brian Reavis <brian@thirdroute.com> 2012-8-27 (cleanup)\n\t */\n\tconst highlight = (element, regex) => {\n\t  if (regex === null) return; // convet string to regex\n\n\t  if (typeof regex === 'string') {\n\t    if (!regex.length) return;\n\t    regex = new RegExp(regex, 'i');\n\t  } // Wrap matching part of text node with highlighting <span>, e.g.\n\t  // Soccer  ->  <span class=\"highlight\">Soc</span>cer  for regex = /soc/i\n\n\n\t  const highlightText = node => {\n\t    var match = node.data.match(regex);\n\n\t    if (match && node.data.length > 0) {\n\t      var spannode = document.createElement('span');\n\t      spannode.className = 'highlight';\n\t      var middlebit = node.splitText(match.index);\n\t      middlebit.splitText(match[0].length);\n\t      var middleclone = middlebit.cloneNode(true);\n\t      spannode.appendChild(middleclone);\n\t      replaceNode(middlebit, spannode);\n\t      return 1;\n\t    }\n\n\t    return 0;\n\t  }; // Recurse element node, looking for child text nodes to highlight, unless element\n\t  // is childless, <script>, <style>, or already highlighted: <span class=\"hightlight\">\n\n\n\t  const highlightChildren = node => {\n\t    if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== 'highlight' || node.tagName !== 'SPAN')) {\n\t      for (var i = 0; i < node.childNodes.length; ++i) {\n\t        i += highlightRecursive(node.childNodes[i]);\n\t      }\n\t    }\n\t  };\n\n\t  const highlightRecursive = node => {\n\t    if (node.nodeType === 3) {\n\t      return highlightText(node);\n\t    }\n\n\t    highlightChildren(node);\n\t    return 0;\n\t  };\n\n\t  highlightRecursive(element);\n\t};\n\t/**\n\t * removeHighlight fn copied from highlight v5 and\n\t * edited to remove with(), pass js strict mode, and use without jquery\n\t */\n\n\tconst removeHighlight = el => {\n\t  var elements = el.querySelectorAll(\"span.highlight\");\n\t  Array.prototype.forEach.call(elements, function (el) {\n\t    var parent = el.parentNode;\n\t    parent.replaceChild(el.firstChild, el);\n\t    parent.normalize();\n\t  });\n\t};\n\n\tconst KEY_A = 65;\n\tconst KEY_RETURN = 13;\n\tconst KEY_ESC = 27;\n\tconst KEY_LEFT = 37;\n\tconst KEY_UP = 38;\n\tconst KEY_RIGHT = 39;\n\tconst KEY_DOWN = 40;\n\tconst KEY_BACKSPACE = 8;\n\tconst KEY_DELETE = 46;\n\tconst KEY_TAB = 9;\n\tconst IS_MAC = typeof navigator === 'undefined' ? false : /Mac/.test(navigator.userAgent);\n\tconst KEY_SHORTCUT = IS_MAC ? 'metaKey' : 'ctrlKey'; // ctrl key or apple key for ma\n\n\tvar defaults = {\n\t  options: [],\n\t  optgroups: [],\n\t  plugins: [],\n\t  delimiter: ',',\n\t  splitOn: null,\n\t  // regexp or string for splitting up values from a paste command\n\t  persist: true,\n\t  diacritics: true,\n\t  create: null,\n\t  createOnBlur: false,\n\t  createFilter: null,\n\t  highlight: true,\n\t  openOnFocus: true,\n\t  shouldOpen: null,\n\t  maxOptions: 50,\n\t  maxItems: null,\n\t  hideSelected: null,\n\t  duplicates: false,\n\t  addPrecedence: false,\n\t  selectOnTab: false,\n\t  preload: null,\n\t  allowEmptyOption: false,\n\t  //closeAfterSelect: false,\n\t  loadThrottle: 300,\n\t  loadingClass: 'loading',\n\t  dataAttr: null,\n\t  //'data-data',\n\t  optgroupField: 'optgroup',\n\t  valueField: 'value',\n\t  labelField: 'text',\n\t  disabledField: 'disabled',\n\t  optgroupLabelField: 'label',\n\t  optgroupValueField: 'value',\n\t  lockOptgroupOrder: false,\n\t  sortField: '$order',\n\t  searchField: ['text'],\n\t  searchConjunction: 'and',\n\t  mode: null,\n\t  wrapperClass: 'ts-wrapper',\n\t  controlClass: 'ts-control',\n\t  dropdownClass: 'ts-dropdown',\n\t  dropdownContentClass: 'ts-dropdown-content',\n\t  itemClass: 'item',\n\t  optionClass: 'option',\n\t  dropdownParent: null,\n\t  controlInput: '<input type=\"text\" autocomplete=\"off\" size=\"1\" />',\n\t  copyClassesToDropdown: false,\n\t  placeholder: null,\n\t  hidePlaceholder: null,\n\t  shouldLoad: function (query) {\n\t    return query.length > 0;\n\t  },\n\n\t  /*\n\t  load                 : null, // function(query, callback) { ... }\n\t  score                : null, // function(search) { ... }\n\t  onInitialize         : null, // function() { ... }\n\t  onChange             : null, // function(value) { ... }\n\t  onItemAdd            : null, // function(value, $item) { ... }\n\t  onItemRemove         : null, // function(value) { ... }\n\t  onClear              : null, // function() { ... }\n\t  onOptionAdd          : null, // function(value, data) { ... }\n\t  onOptionRemove       : null, // function(value) { ... }\n\t  onOptionClear        : null, // function() { ... }\n\t  onOptionGroupAdd     : null, // function(id, data) { ... }\n\t  onOptionGroupRemove  : null, // function(id) { ... }\n\t  onOptionGroupClear   : null, // function() { ... }\n\t  onDropdownOpen       : null, // function(dropdown) { ... }\n\t  onDropdownClose      : null, // function(dropdown) { ... }\n\t  onType               : null, // function(str) { ... }\n\t  onDelete             : null, // function(values) { ... }\n\t  */\n\t  render: {\n\t    /*\n\t    item: null,\n\t    optgroup: null,\n\t    optgroup_header: null,\n\t    option: null,\n\t    option_create: null\n\t    */\n\t  }\n\t};\n\n\t/**\n\t * Converts a scalar to its best string representation\n\t * for hash keys and HTML attribute values.\n\t *\n\t * Transformations:\n\t *   'str'     -> 'str'\n\t *   null      -> ''\n\t *   undefined -> ''\n\t *   true      -> '1'\n\t *   false     -> '0'\n\t *   0         -> '0'\n\t *   1         -> '1'\n\t *\n\t */\n\tconst hash_key = value => {\n\t  if (typeof value === 'undefined' || value === null) return null;\n\t  return get_hash(value);\n\t};\n\tconst get_hash = value => {\n\t  if (typeof value === 'boolean') return value ? '1' : '0';\n\t  return value + '';\n\t};\n\t/**\n\t * Escapes a string for use within HTML.\n\t *\n\t */\n\n\tconst escape_html = str => {\n\t  return (str + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n\t};\n\t/**\n\t * Debounce the user provided load function\n\t *\n\t */\n\n\tconst loadDebounce = (fn, delay) => {\n\t  var timeout;\n\t  return function (value, callback) {\n\t    var self = this;\n\n\t    if (timeout) {\n\t      self.loading = Math.max(self.loading - 1, 0);\n\t      clearTimeout(timeout);\n\t    }\n\n\t    timeout = setTimeout(function () {\n\t      timeout = null;\n\t      self.loadedSearches[value] = true;\n\t      fn.call(self, value, callback);\n\t    }, delay);\n\t  };\n\t};\n\t/**\n\t * Debounce all fired events types listed in `types`\n\t * while executing the provided `fn`.\n\t *\n\t */\n\n\tconst debounce_events = (self, types, fn) => {\n\t  var type;\n\t  var trigger = self.trigger;\n\t  var event_args = {}; // override trigger method\n\n\t  self.trigger = function () {\n\t    var type = arguments[0];\n\n\t    if (types.indexOf(type) !== -1) {\n\t      event_args[type] = arguments;\n\t    } else {\n\t      return trigger.apply(self, arguments);\n\t    }\n\t  }; // invoke provided function\n\n\n\t  fn.apply(self, []);\n\t  self.trigger = trigger; // trigger queued events\n\n\t  for (type of types) {\n\t    if (type in event_args) {\n\t      trigger.apply(self, event_args[type]);\n\t    }\n\t  }\n\t};\n\t/**\n\t * Determines the current selection within a text input control.\n\t * Returns an object containing:\n\t *   - start\n\t *   - length\n\t *\n\t */\n\n\tconst getSelection = input => {\n\t  return {\n\t    start: input.selectionStart || 0,\n\t    length: (input.selectionEnd || 0) - (input.selectionStart || 0)\n\t  };\n\t};\n\t/**\n\t * Prevent default\n\t *\n\t */\n\n\tconst preventDefault = (evt, stop = false) => {\n\t  if (evt) {\n\t    evt.preventDefault();\n\n\t    if (stop) {\n\t      evt.stopPropagation();\n\t    }\n\t  }\n\t};\n\t/**\n\t * Prevent default\n\t *\n\t */\n\n\tconst addEvent = (target, type, callback, options) => {\n\t  target.addEventListener(type, callback, options);\n\t};\n\t/**\n\t * Return true if the requested key is down\n\t * Will return false if more than one control character is pressed ( when [ctrl+shift+a] != [ctrl+a] )\n\t * The current evt may not always set ( eg calling advanceSelection() )\n\t *\n\t */\n\n\tconst isKeyDown = (key_name, evt) => {\n\t  if (!evt) {\n\t    return false;\n\t  }\n\n\t  if (!evt[key_name]) {\n\t    return false;\n\t  }\n\n\t  var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);\n\n\t  if (count === 1) {\n\t    return true;\n\t  }\n\n\t  return false;\n\t};\n\t/**\n\t * Get the id of an element\n\t * If the id attribute is not set, set the attribute with the given id\n\t *\n\t */\n\n\tconst getId = (el, id) => {\n\t  const existing_id = el.getAttribute('id');\n\n\t  if (existing_id) {\n\t    return existing_id;\n\t  }\n\n\t  el.setAttribute('id', id);\n\t  return id;\n\t};\n\t/**\n\t * Returns a string with backslashes added before characters that need to be escaped.\n\t */\n\n\tconst addSlashes = str => {\n\t  return str.replace(/[\\\\\"']/g, '\\\\$&');\n\t};\n\t/**\n\t *\n\t */\n\n\tconst append = (parent, node) => {\n\t  if (node) parent.append(node);\n\t};\n\n\tfunction getSettings(input, settings_user) {\n\t  var settings = Object.assign({}, defaults, settings_user);\n\t  var attr_data = settings.dataAttr;\n\t  var field_label = settings.labelField;\n\t  var field_value = settings.valueField;\n\t  var field_disabled = settings.disabledField;\n\t  var field_optgroup = settings.optgroupField;\n\t  var field_optgroup_label = settings.optgroupLabelField;\n\t  var field_optgroup_value = settings.optgroupValueField;\n\t  var tag_name = input.tagName.toLowerCase();\n\t  var placeholder = input.getAttribute('placeholder') || input.getAttribute('data-placeholder');\n\n\t  if (!placeholder && !settings.allowEmptyOption) {\n\t    let option = input.querySelector('option[value=\"\"]');\n\n\t    if (option) {\n\t      placeholder = option.textContent;\n\t    }\n\t  }\n\n\t  var settings_element = {\n\t    placeholder: placeholder,\n\t    options: [],\n\t    optgroups: [],\n\t    items: [],\n\t    maxItems: null\n\t  };\n\t  /**\n\t   * Initialize from a <select> element.\n\t   *\n\t   */\n\n\t  var init_select = () => {\n\t    var tagName;\n\t    var options = settings_element.options;\n\t    var optionsMap = {};\n\t    var group_count = 1;\n\n\t    var readData = el => {\n\t      var data = Object.assign({}, el.dataset); // get plain object from DOMStringMap\n\n\t      var json = attr_data && data[attr_data];\n\n\t      if (typeof json === 'string' && json.length) {\n\t        data = Object.assign(data, JSON.parse(json));\n\t      }\n\n\t      return data;\n\t    };\n\n\t    var addOption = (option, group) => {\n\t      var value = hash_key(option.value);\n\t      if (value == null) return;\n\t      if (!value && !settings.allowEmptyOption) return; // if the option already exists, it's probably been\n\t      // duplicated in another optgroup. in this case, push\n\t      // the current group to the \"optgroup\" property on the\n\t      // existing option so that it's rendered in both places.\n\n\t      if (optionsMap.hasOwnProperty(value)) {\n\t        if (group) {\n\t          var arr = optionsMap[value][field_optgroup];\n\n\t          if (!arr) {\n\t            optionsMap[value][field_optgroup] = group;\n\t          } else if (!Array.isArray(arr)) {\n\t            optionsMap[value][field_optgroup] = [arr, group];\n\t          } else {\n\t            arr.push(group);\n\t          }\n\t        }\n\t      } else {\n\t        var option_data = readData(option);\n\t        option_data[field_label] = option_data[field_label] || option.textContent;\n\t        option_data[field_value] = option_data[field_value] || value;\n\t        option_data[field_disabled] = option_data[field_disabled] || option.disabled;\n\t        option_data[field_optgroup] = option_data[field_optgroup] || group;\n\t        option_data.$option = option;\n\t        optionsMap[value] = option_data;\n\t        options.push(option_data);\n\t      }\n\n\t      if (option.selected) {\n\t        settings_element.items.push(value);\n\t      }\n\t    };\n\n\t    var addGroup = optgroup => {\n\t      var id, optgroup_data;\n\t      optgroup_data = readData(optgroup);\n\t      optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute('label') || '';\n\t      optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;\n\t      optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;\n\t      settings_element.optgroups.push(optgroup_data);\n\t      id = optgroup_data[field_optgroup_value];\n\t      iterate(optgroup.children, option => {\n\t        addOption(option, id);\n\t      });\n\t    };\n\n\t    settings_element.maxItems = input.hasAttribute('multiple') ? null : 1;\n\t    iterate(input.children, child => {\n\t      tagName = child.tagName.toLowerCase();\n\n\t      if (tagName === 'optgroup') {\n\t        addGroup(child);\n\t      } else if (tagName === 'option') {\n\t        addOption(child);\n\t      }\n\t    });\n\t  };\n\t  /**\n\t   * Initialize from a <input type=\"text\"> element.\n\t   *\n\t   */\n\n\n\t  var init_textbox = () => {\n\t    const data_raw = input.getAttribute(attr_data);\n\n\t    if (!data_raw) {\n\t      var value = input.value.trim() || '';\n\t      if (!settings.allowEmptyOption && !value.length) return;\n\t      const values = value.split(settings.delimiter);\n\t      iterate(values, value => {\n\t        const option = {};\n\t        option[field_label] = value;\n\t        option[field_value] = value;\n\t        settings_element.options.push(option);\n\t      });\n\t      settings_element.items = values;\n\t    } else {\n\t      settings_element.options = JSON.parse(data_raw);\n\t      iterate(settings_element.options, opt => {\n\t        settings_element.items.push(opt[field_value]);\n\t      });\n\t    }\n\t  };\n\n\t  if (tag_name === 'select') {\n\t    init_select();\n\t  } else {\n\t    init_textbox();\n\t  }\n\n\t  return Object.assign({}, defaults, settings_element, settings_user);\n\t}\n\n\tvar instance_i = 0;\n\tclass TomSelect extends MicroPlugin(MicroEvent) {\n\t  // @deprecated 1.8\n\t  constructor(input_arg, user_settings) {\n\t    super();\n\t    this.control_input = void 0;\n\t    this.wrapper = void 0;\n\t    this.dropdown = void 0;\n\t    this.control = void 0;\n\t    this.dropdown_content = void 0;\n\t    this.focus_node = void 0;\n\t    this.order = 0;\n\t    this.settings = void 0;\n\t    this.input = void 0;\n\t    this.tabIndex = void 0;\n\t    this.is_select_tag = void 0;\n\t    this.rtl = void 0;\n\t    this.inputId = void 0;\n\t    this._destroy = void 0;\n\t    this.sifter = void 0;\n\t    this.isOpen = false;\n\t    this.isDisabled = false;\n\t    this.isRequired = void 0;\n\t    this.isInvalid = false;\n\t    this.isValid = true;\n\t    this.isLocked = false;\n\t    this.isFocused = false;\n\t    this.isInputHidden = false;\n\t    this.isSetup = false;\n\t    this.ignoreFocus = false;\n\t    this.ignoreHover = false;\n\t    this.hasOptions = false;\n\t    this.currentResults = void 0;\n\t    this.lastValue = '';\n\t    this.caretPos = 0;\n\t    this.loading = 0;\n\t    this.loadedSearches = {};\n\t    this.activeOption = null;\n\t    this.activeItems = [];\n\t    this.optgroups = {};\n\t    this.options = {};\n\t    this.userOptions = {};\n\t    this.items = [];\n\t    instance_i++;\n\t    var dir;\n\t    var input = getDom(input_arg);\n\n\t    if (input.tomselect) {\n\t      throw new Error('Tom Select already initialized on this element');\n\t    }\n\n\t    input.tomselect = this; // detect rtl environment\n\n\t    var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);\n\t    dir = computedStyle.getPropertyValue('direction'); // setup default state\n\n\t    const settings = getSettings(input, user_settings);\n\t    this.settings = settings;\n\t    this.input = input;\n\t    this.tabIndex = input.tabIndex || 0;\n\t    this.is_select_tag = input.tagName.toLowerCase() === 'select';\n\t    this.rtl = /rtl/i.test(dir);\n\t    this.inputId = getId(input, 'tomselect-' + instance_i);\n\t    this.isRequired = input.required; // search system\n\n\t    this.sifter = new Sifter(this.options, {\n\t      diacritics: settings.diacritics\n\t    }); // option-dependent defaults\n\n\t    settings.mode = settings.mode || (settings.maxItems === 1 ? 'single' : 'multi');\n\n\t    if (typeof settings.hideSelected !== 'boolean') {\n\t      settings.hideSelected = settings.mode === 'multi';\n\t    }\n\n\t    if (typeof settings.hidePlaceholder !== 'boolean') {\n\t      settings.hidePlaceholder = settings.mode !== 'multi';\n\t    } // set up createFilter callback\n\n\n\t    var filter = settings.createFilter;\n\n\t    if (typeof filter !== 'function') {\n\t      if (typeof filter === 'string') {\n\t        filter = new RegExp(filter);\n\t      }\n\n\t      if (filter instanceof RegExp) {\n\t        settings.createFilter = input => filter.test(input);\n\t      } else {\n\t        settings.createFilter = value => {\n\t          return this.settings.duplicates || !this.options[value];\n\t        };\n\t      }\n\t    }\n\n\t    this.initializePlugins(settings.plugins);\n\t    this.setupCallbacks();\n\t    this.setupTemplates(); // Create all elements\n\n\t    const wrapper = getDom('<div>');\n\t    const control = getDom('<div>');\n\n\t    const dropdown = this._render('dropdown');\n\n\t    const dropdown_content = getDom(`<div role=\"listbox\" tabindex=\"-1\">`);\n\t    const classes = this.input.getAttribute('class') || '';\n\t    const inputMode = settings.mode;\n\t    var control_input;\n\t    addClasses(wrapper, settings.wrapperClass, classes, inputMode);\n\t    addClasses(control, settings.controlClass);\n\t    append(wrapper, control);\n\t    addClasses(dropdown, settings.dropdownClass, inputMode);\n\n\t    if (settings.copyClassesToDropdown) {\n\t      addClasses(dropdown, classes);\n\t    }\n\n\t    addClasses(dropdown_content, settings.dropdownContentClass);\n\t    append(dropdown, dropdown_content);\n\t    getDom(settings.dropdownParent || wrapper).appendChild(dropdown); // default controlInput\n\n\t    if (isHtmlString(settings.controlInput)) {\n\t      control_input = getDom(settings.controlInput); // set attributes\n\n\t      var attrs = ['autocorrect', 'autocapitalize', 'autocomplete'];\n\t      iterate(attrs, attr => {\n\t        if (input.getAttribute(attr)) {\n\t          setAttr(control_input, {\n\t            [attr]: input.getAttribute(attr)\n\t          });\n\t        }\n\t      });\n\t      control_input.tabIndex = -1;\n\t      control.appendChild(control_input);\n\t      this.focus_node = control_input; // dom element\n\t    } else if (settings.controlInput) {\n\t      control_input = getDom(settings.controlInput);\n\t      this.focus_node = control_input;\n\t    } else {\n\t      control_input = getDom('<input/>');\n\t      this.focus_node = control;\n\t    }\n\n\t    this.wrapper = wrapper;\n\t    this.dropdown = dropdown;\n\t    this.dropdown_content = dropdown_content;\n\t    this.control = control;\n\t    this.control_input = control_input;\n\t    this.setup();\n\t  }\n\t  /**\n\t   * set up event bindings.\n\t   *\n\t   */\n\n\n\t  setup() {\n\t    const self = this;\n\t    const settings = self.settings;\n\t    const control_input = self.control_input;\n\t    const dropdown = self.dropdown;\n\t    const dropdown_content = self.dropdown_content;\n\t    const wrapper = self.wrapper;\n\t    const control = self.control;\n\t    const input = self.input;\n\t    const focus_node = self.focus_node;\n\t    const passive_event = {\n\t      passive: true\n\t    };\n\t    const listboxId = self.inputId + '-ts-dropdown';\n\t    setAttr(dropdown_content, {\n\t      id: listboxId\n\t    });\n\t    setAttr(focus_node, {\n\t      role: 'combobox',\n\t      'aria-haspopup': 'listbox',\n\t      'aria-expanded': 'false',\n\t      'aria-controls': listboxId\n\t    });\n\t    const control_id = getId(focus_node, self.inputId + '-ts-control');\n\t    const query = \"label[for='\" + escapeQuery(self.inputId) + \"']\";\n\t    const label = document.querySelector(query);\n\t    const label_click = self.focus.bind(self);\n\n\t    if (label) {\n\t      addEvent(label, 'click', label_click);\n\t      setAttr(label, {\n\t        for: control_id\n\t      });\n\t      const label_id = getId(label, self.inputId + '-ts-label');\n\t      setAttr(focus_node, {\n\t        'aria-labelledby': label_id\n\t      });\n\t      setAttr(dropdown_content, {\n\t        'aria-labelledby': label_id\n\t      });\n\t    }\n\n\t    wrapper.style.width = input.style.width;\n\n\t    if (self.plugins.names.length) {\n\t      const classes_plugins = 'plugin-' + self.plugins.names.join(' plugin-');\n\t      addClasses([wrapper, dropdown], classes_plugins);\n\t    }\n\n\t    if ((settings.maxItems === null || settings.maxItems > 1) && self.is_select_tag) {\n\t      setAttr(input, {\n\t        multiple: 'multiple'\n\t      });\n\t    }\n\n\t    if (settings.placeholder) {\n\t      setAttr(control_input, {\n\t        placeholder: settings.placeholder\n\t      });\n\t    } // if splitOn was not passed in, construct it from the delimiter to allow pasting universally\n\n\n\t    if (!settings.splitOn && settings.delimiter) {\n\t      settings.splitOn = new RegExp('\\\\s*' + escape_regex(settings.delimiter) + '+\\\\s*');\n\t    } // debounce user defined load() if loadThrottle > 0\n\t    // after initializePlugins() so plugins can create/modify user defined loaders\n\n\n\t    if (settings.load && settings.loadThrottle) {\n\t      settings.load = loadDebounce(settings.load, settings.loadThrottle);\n\t    }\n\n\t    self.control_input.type = input.type;\n\t    addEvent(dropdown, 'mouseenter', e => {\n\t      var target_match = parentMatch(e.target, '[data-selectable]', dropdown);\n\t      if (target_match) self.onOptionHover(e, target_match);\n\t    }, {\n\t      capture: true\n\t    }); // clicking on an option should select it\n\n\t    addEvent(dropdown, 'click', evt => {\n\t      const option = parentMatch(evt.target, '[data-selectable]');\n\n\t      if (option) {\n\t        self.onOptionSelect(evt, option);\n\t        preventDefault(evt, true);\n\t      }\n\t    });\n\t    addEvent(control, 'click', evt => {\n\t      var target_match = parentMatch(evt.target, '[data-ts-item]', control);\n\n\t      if (target_match && self.onItemSelect(evt, target_match)) {\n\t        preventDefault(evt, true);\n\t        return;\n\t      } // retain focus (see control_input mousedown)\n\n\n\t      if (control_input.value != '') {\n\t        return;\n\t      }\n\n\t      self.onClick();\n\t      preventDefault(evt, true);\n\t    }); // keydown on focus_node for arrow_down/arrow_up\n\n\t    addEvent(focus_node, 'keydown', e => self.onKeyDown(e)); // keypress and input/keyup\n\n\t    addEvent(control_input, 'keypress', e => self.onKeyPress(e));\n\t    addEvent(control_input, 'input', e => self.onInput(e));\n\t    addEvent(focus_node, 'resize', () => self.positionDropdown(), passive_event);\n\t    addEvent(focus_node, 'blur', e => self.onBlur(e));\n\t    addEvent(focus_node, 'focus', e => self.onFocus(e));\n\t    addEvent(control_input, 'paste', e => self.onPaste(e));\n\n\t    const doc_mousedown = evt => {\n\t      // blur if target is outside of this instance\n\t      // dropdown is not always inside wrapper\n\t      const target = evt.composedPath()[0];\n\n\t      if (!wrapper.contains(target) && !dropdown.contains(target)) {\n\t        if (self.isFocused) {\n\t          self.blur();\n\t        }\n\n\t        self.inputState();\n\t        return;\n\t      } // retain focus by preventing native handling. if the\n\t      // event target is the input it should not be modified.\n\t      // otherwise, text selection within the input won't work.\n\t      // Fixes bug #212 which is no covered by tests\n\n\n\t      if (target == control_input && self.isOpen) {\n\t        evt.stopPropagation(); // clicking anywhere in the control should not blur the control_input (which would close the dropdown)\n\t      } else {\n\t        preventDefault(evt, true);\n\t      }\n\t    };\n\n\t    const win_scroll = () => {\n\t      if (self.isOpen) {\n\t        self.positionDropdown();\n\t      }\n\t    };\n\n\t    const win_hover = () => {\n\t      self.ignoreHover = false;\n\t    };\n\n\t    addEvent(document, 'mousedown', doc_mousedown);\n\t    addEvent(window, 'scroll', win_scroll, passive_event);\n\t    addEvent(window, 'resize', win_scroll, passive_event);\n\t    addEvent(window, 'mousemove', win_hover, passive_event);\n\n\t    this._destroy = () => {\n\t      document.removeEventListener('mousedown', doc_mousedown);\n\t      window.removeEventListener('mousemove', win_hover);\n\t      window.removeEventListener('scroll', win_scroll);\n\t      window.removeEventListener('resize', win_scroll);\n\t      if (label) label.removeEventListener('click', label_click);\n\t    }; // store original html and tab index so that they can be\n\t    // restored when the destroy() method is called.\n\n\n\t    this.revertSettings = {\n\t      innerHTML: input.innerHTML,\n\t      tabIndex: input.tabIndex\n\t    };\n\t    input.tabIndex = -1;\n\t    input.insertAdjacentElement('afterend', self.wrapper);\n\t    self.sync(false);\n\t    settings.items = [];\n\t    delete settings.optgroups;\n\t    delete settings.options;\n\t    addEvent(input, 'invalid', e => {\n\t      if (self.isValid) {\n\t        self.isValid = false;\n\t        self.isInvalid = true;\n\t        self.refreshState();\n\t      }\n\t    });\n\t    self.updateOriginalInput();\n\t    self.refreshItems();\n\t    self.close(false);\n\t    self.inputState();\n\t    self.isSetup = true;\n\n\t    if (input.disabled) {\n\t      self.disable();\n\t    } else {\n\t      self.enable(); //sets tabIndex\n\t    }\n\n\t    self.on('change', this.onChange);\n\t    addClasses(input, 'tomselected', 'ts-hidden-accessible');\n\t    self.trigger('initialize'); // preload options\n\n\t    if (settings.preload === true) {\n\t      self.preload();\n\t    }\n\t  }\n\t  /**\n\t   * Register options and optgroups\n\t   *\n\t   */\n\n\n\t  setupOptions(options = [], optgroups = []) {\n\t    // build options table\n\t    this.addOptions(options); // build optgroup table\n\n\t    iterate(optgroups, optgroup => {\n\t      this.registerOptionGroup(optgroup);\n\t    });\n\t  }\n\t  /**\n\t   * Sets up default rendering functions.\n\t   */\n\n\n\t  setupTemplates() {\n\t    var self = this;\n\t    var field_label = self.settings.labelField;\n\t    var field_optgroup = self.settings.optgroupLabelField;\n\t    var templates = {\n\t      'optgroup': data => {\n\t        let optgroup = document.createElement('div');\n\t        optgroup.className = 'optgroup';\n\t        optgroup.appendChild(data.options);\n\t        return optgroup;\n\t      },\n\t      'optgroup_header': (data, escape) => {\n\t        return '<div class=\"optgroup-header\">' + escape(data[field_optgroup]) + '</div>';\n\t      },\n\t      'option': (data, escape) => {\n\t        return '<div>' + escape(data[field_label]) + '</div>';\n\t      },\n\t      'item': (data, escape) => {\n\t        return '<div>' + escape(data[field_label]) + '</div>';\n\t      },\n\t      'option_create': (data, escape) => {\n\t        return '<div class=\"create\">Add <strong>' + escape(data.input) + '</strong>&hellip;</div>';\n\t      },\n\t      'no_results': () => {\n\t        return '<div class=\"no-results\">No results found</div>';\n\t      },\n\t      'loading': () => {\n\t        return '<div class=\"spinner\"></div>';\n\t      },\n\t      'not_loading': () => {},\n\t      'dropdown': () => {\n\t        return '<div></div>';\n\t      }\n\t    };\n\t    self.settings.render = Object.assign({}, templates, self.settings.render);\n\t  }\n\t  /**\n\t   * Maps fired events to callbacks provided\n\t   * in the settings used when creating the control.\n\t   */\n\n\n\t  setupCallbacks() {\n\t    var key, fn;\n\t    var callbacks = {\n\t      'initialize': 'onInitialize',\n\t      'change': 'onChange',\n\t      'item_add': 'onItemAdd',\n\t      'item_remove': 'onItemRemove',\n\t      'item_select': 'onItemSelect',\n\t      'clear': 'onClear',\n\t      'option_add': 'onOptionAdd',\n\t      'option_remove': 'onOptionRemove',\n\t      'option_clear': 'onOptionClear',\n\t      'optgroup_add': 'onOptionGroupAdd',\n\t      'optgroup_remove': 'onOptionGroupRemove',\n\t      'optgroup_clear': 'onOptionGroupClear',\n\t      'dropdown_open': 'onDropdownOpen',\n\t      'dropdown_close': 'onDropdownClose',\n\t      'type': 'onType',\n\t      'load': 'onLoad',\n\t      'focus': 'onFocus',\n\t      'blur': 'onBlur'\n\t    };\n\n\t    for (key in callbacks) {\n\t      fn = this.settings[callbacks[key]];\n\t      if (fn) this.on(key, fn);\n\t    }\n\t  }\n\t  /**\n\t   * Sync the Tom Select instance with the original input or select\n\t   *\n\t   */\n\n\n\t  sync(get_settings = true) {\n\t    const self = this;\n\t    const settings = get_settings ? getSettings(self.input, {\n\t      delimiter: self.settings.delimiter\n\t    }) : self.settings;\n\t    self.setupOptions(settings.options, settings.optgroups);\n\t    self.setValue(settings.items || [], true); // silent prevents recursion\n\n\t    self.lastQuery = null; // so updated options will be displayed in dropdown\n\t  }\n\t  /**\n\t   * Triggered when the main control element\n\t   * has a click event.\n\t   *\n\t   */\n\n\n\t  onClick() {\n\t    var self = this;\n\n\t    if (self.activeItems.length > 0) {\n\t      self.clearActiveItems();\n\t      self.focus();\n\t      return;\n\t    }\n\n\t    if (self.isFocused && self.isOpen) {\n\t      self.blur();\n\t    } else {\n\t      self.focus();\n\t    }\n\t  }\n\t  /**\n\t   * @deprecated v1.7\n\t   *\n\t   */\n\n\n\t  onMouseDown() {}\n\t  /**\n\t   * Triggered when the value of the control has been changed.\n\t   * This should propagate the event to the original DOM\n\t   * input / select element.\n\t   */\n\n\n\t  onChange() {\n\t    triggerEvent(this.input, 'input');\n\t    triggerEvent(this.input, 'change');\n\t  }\n\t  /**\n\t   * Triggered on <input> paste.\n\t   *\n\t   */\n\n\n\t  onPaste(e) {\n\t    var self = this;\n\n\t    if (self.isInputHidden || self.isLocked) {\n\t      preventDefault(e);\n\t      return;\n\t    } // If a regex or string is included, this will split the pasted\n\t    // input and create Items for each separate value\n\n\n\t    if (!self.settings.splitOn) {\n\t      return;\n\t    } // Wait for pasted text to be recognized in value\n\n\n\t    setTimeout(() => {\n\t      var pastedText = self.inputValue();\n\n\t      if (!pastedText.match(self.settings.splitOn)) {\n\t        return;\n\t      }\n\n\t      var splitInput = pastedText.trim().split(self.settings.splitOn);\n\t      iterate(splitInput, piece => {\n\t        piece = hash_key(piece);\n\n\t        if (this.options[piece]) {\n\t          self.addItem(piece);\n\t        } else {\n\t          self.createItem(piece);\n\t        }\n\t      });\n\t    }, 0);\n\t  }\n\t  /**\n\t   * Triggered on <input> keypress.\n\t   *\n\t   */\n\n\n\t  onKeyPress(e) {\n\t    var self = this;\n\n\t    if (self.isLocked) {\n\t      preventDefault(e);\n\t      return;\n\t    }\n\n\t    var character = String.fromCharCode(e.keyCode || e.which);\n\n\t    if (self.settings.create && self.settings.mode === 'multi' && character === self.settings.delimiter) {\n\t      self.createItem();\n\t      preventDefault(e);\n\t      return;\n\t    }\n\t  }\n\t  /**\n\t   * Triggered on <input> keydown.\n\t   *\n\t   */\n\n\n\t  onKeyDown(e) {\n\t    var self = this;\n\t    self.ignoreHover = true;\n\n\t    if (self.isLocked) {\n\t      if (e.keyCode !== KEY_TAB) {\n\t        preventDefault(e);\n\t      }\n\n\t      return;\n\t    }\n\n\t    switch (e.keyCode) {\n\t      // ctrl+A: select all\n\t      case KEY_A:\n\t        if (isKeyDown(KEY_SHORTCUT, e)) {\n\t          if (self.control_input.value == '') {\n\t            preventDefault(e);\n\t            self.selectAll();\n\t            return;\n\t          }\n\t        }\n\n\t        break;\n\t      // esc: close dropdown\n\n\t      case KEY_ESC:\n\t        if (self.isOpen) {\n\t          preventDefault(e, true);\n\t          self.close();\n\t        }\n\n\t        self.clearActiveItems();\n\t        return;\n\t      // down: open dropdown or move selection down\n\n\t      case KEY_DOWN:\n\t        if (!self.isOpen && self.hasOptions) {\n\t          self.open();\n\t        } else if (self.activeOption) {\n\t          let next = self.getAdjacent(self.activeOption, 1);\n\t          if (next) self.setActiveOption(next);\n\t        }\n\n\t        preventDefault(e);\n\t        return;\n\t      // up: move selection up\n\n\t      case KEY_UP:\n\t        if (self.activeOption) {\n\t          let prev = self.getAdjacent(self.activeOption, -1);\n\t          if (prev) self.setActiveOption(prev);\n\t        }\n\n\t        preventDefault(e);\n\t        return;\n\t      // return: select active option\n\n\t      case KEY_RETURN:\n\t        if (self.canSelect(self.activeOption)) {\n\t          self.onOptionSelect(e, self.activeOption);\n\t          preventDefault(e); // if the option_create=null, the dropdown might be closed\n\t        } else if (self.settings.create && self.createItem()) {\n\t          preventDefault(e); // don't submit form when searching for a value\n\t        } else if (document.activeElement == self.control_input && self.isOpen) {\n\t          preventDefault(e);\n\t        }\n\n\t        return;\n\t      // left: modifiy item selection to the left\n\n\t      case KEY_LEFT:\n\t        self.advanceSelection(-1, e);\n\t        return;\n\t      // right: modifiy item selection to the right\n\n\t      case KEY_RIGHT:\n\t        self.advanceSelection(1, e);\n\t        return;\n\t      // tab: select active option and/or create item\n\n\t      case KEY_TAB:\n\t        if (self.settings.selectOnTab) {\n\t          if (self.canSelect(self.activeOption)) {\n\t            self.onOptionSelect(e, self.activeOption); // prevent default [tab] behaviour of jump to the next field\n\t            // if select isFull, then the dropdown won't be open and [tab] will work normally\n\n\t            preventDefault(e);\n\t          }\n\n\t          if (self.settings.create && self.createItem()) {\n\t            preventDefault(e);\n\t          }\n\t        }\n\n\t        return;\n\t      // delete|backspace: delete items\n\n\t      case KEY_BACKSPACE:\n\t      case KEY_DELETE:\n\t        self.deleteSelection(e);\n\t        return;\n\t    } // don't enter text in the control_input when active items are selected\n\n\n\t    if (self.isInputHidden && !isKeyDown(KEY_SHORTCUT, e)) {\n\t      preventDefault(e);\n\t    }\n\t  }\n\t  /**\n\t   * Triggered on <input> keyup.\n\t   *\n\t   */\n\n\n\t  onInput(e) {\n\t    var self = this;\n\n\t    if (self.isLocked) {\n\t      return;\n\t    }\n\n\t    var value = self.inputValue();\n\n\t    if (self.lastValue !== value) {\n\t      self.lastValue = value;\n\n\t      if (self.settings.shouldLoad.call(self, value)) {\n\t        self.load(value);\n\t      }\n\n\t      self.refreshOptions();\n\t      self.trigger('type', value);\n\t    }\n\t  }\n\t  /**\n\t   * Triggered when the user rolls over\n\t   * an option in the autocomplete dropdown menu.\n\t   *\n\t   */\n\n\n\t  onOptionHover(evt, option) {\n\t    if (this.ignoreHover) return;\n\t    this.setActiveOption(option, false);\n\t  }\n\t  /**\n\t   * Triggered on <input> focus.\n\t   *\n\t   */\n\n\n\t  onFocus(e) {\n\t    var self = this;\n\t    var wasFocused = self.isFocused;\n\n\t    if (self.isDisabled) {\n\t      self.blur();\n\t      preventDefault(e);\n\t      return;\n\t    }\n\n\t    if (self.ignoreFocus) return;\n\t    self.isFocused = true;\n\t    if (self.settings.preload === 'focus') self.preload();\n\t    if (!wasFocused) self.trigger('focus');\n\n\t    if (!self.activeItems.length) {\n\t      self.showInput();\n\t      self.refreshOptions(!!self.settings.openOnFocus);\n\t    }\n\n\t    self.refreshState();\n\t  }\n\t  /**\n\t   * Triggered on <input> blur.\n\t   *\n\t   */\n\n\n\t  onBlur(e) {\n\t    if (document.hasFocus() === false) return;\n\t    var self = this;\n\t    if (!self.isFocused) return;\n\t    self.isFocused = false;\n\t    self.ignoreFocus = false;\n\n\t    var deactivate = () => {\n\t      self.close();\n\t      self.setActiveItem();\n\t      self.setCaret(self.items.length);\n\t      self.trigger('blur');\n\t    };\n\n\t    if (self.settings.create && self.settings.createOnBlur) {\n\t      self.createItem(null, false, deactivate);\n\t    } else {\n\t      deactivate();\n\t    }\n\t  }\n\t  /**\n\t   * Triggered when the user clicks on an option\n\t   * in the autocomplete dropdown menu.\n\t   *\n\t   */\n\n\n\t  onOptionSelect(evt, option) {\n\t    var value,\n\t        self = this; // should not be possible to trigger a option under a disabled optgroup\n\n\t    if (option.parentElement && option.parentElement.matches('[data-disabled]')) {\n\t      return;\n\t    }\n\n\t    if (option.classList.contains('create')) {\n\t      self.createItem(null, true, () => {\n\t        if (self.settings.closeAfterSelect) {\n\t          self.close();\n\t        }\n\t      });\n\t    } else {\n\t      value = option.dataset.value;\n\n\t      if (typeof value !== 'undefined') {\n\t        self.lastQuery = null;\n\t        self.addItem(value);\n\n\t        if (self.settings.closeAfterSelect) {\n\t          self.close();\n\t        }\n\n\t        if (!self.settings.hideSelected && evt.type && /click/.test(evt.type)) {\n\t          self.setActiveOption(option);\n\t        }\n\t      }\n\t    }\n\t  }\n\t  /**\n\t   * Return true if the given option can be selected\n\t   *\n\t   */\n\n\n\t  canSelect(option) {\n\t    if (this.isOpen && option && this.dropdown_content.contains(option)) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\t  /**\n\t   * Triggered when the user clicks on an item\n\t   * that has been selected.\n\t   *\n\t   */\n\n\n\t  onItemSelect(evt, item) {\n\t    var self = this;\n\n\t    if (!self.isLocked && self.settings.mode === 'multi') {\n\t      preventDefault(evt);\n\t      self.setActiveItem(item, evt);\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\t  /**\n\t   * Determines whether or not to invoke\n\t   * the user-provided option provider / loader\n\t   *\n\t   * Note, there is a subtle difference between\n\t   * this.canLoad() and this.settings.shouldLoad();\n\t   *\n\t   *\t- settings.shouldLoad() is a user-input validator.\n\t   *\tWhen false is returned, the not_loading template\n\t   *\twill be added to the dropdown\n\t   *\n\t   *\t- canLoad() is lower level validator that checks\n\t   * \tthe Tom Select instance. There is no inherent user\n\t   *\tfeedback when canLoad returns false\n\t   *\n\t   */\n\n\n\t  canLoad(value) {\n\t    if (!this.settings.load) return false;\n\t    if (this.loadedSearches.hasOwnProperty(value)) return false;\n\t    return true;\n\t  }\n\t  /**\n\t   * Invokes the user-provided option provider / loader.\n\t   *\n\t   */\n\n\n\t  load(value) {\n\t    const self = this;\n\t    if (!self.canLoad(value)) return;\n\t    addClasses(self.wrapper, self.settings.loadingClass);\n\t    self.loading++;\n\t    const callback = self.loadCallback.bind(self);\n\t    self.settings.load.call(self, value, callback);\n\t  }\n\t  /**\n\t   * Invoked by the user-provided option provider\n\t   *\n\t   */\n\n\n\t  loadCallback(options, optgroups) {\n\t    const self = this;\n\t    self.loading = Math.max(self.loading - 1, 0);\n\t    self.lastQuery = null;\n\t    self.clearActiveOption(); // when new results load, focus should be on first option\n\n\t    self.setupOptions(options, optgroups);\n\t    self.refreshOptions(self.isFocused && !self.isInputHidden);\n\n\t    if (!self.loading) {\n\t      removeClasses(self.wrapper, self.settings.loadingClass);\n\t    }\n\n\t    self.trigger('load', options, optgroups);\n\t  }\n\n\t  preload() {\n\t    var classList = this.wrapper.classList;\n\t    if (classList.contains('preloaded')) return;\n\t    classList.add('preloaded');\n\t    this.load('');\n\t  }\n\t  /**\n\t   * Sets the input field of the control to the specified value.\n\t   *\n\t   */\n\n\n\t  setTextboxValue(value = '') {\n\t    var input = this.control_input;\n\t    var changed = input.value !== value;\n\n\t    if (changed) {\n\t      input.value = value;\n\t      triggerEvent(input, 'update');\n\t      this.lastValue = value;\n\t    }\n\t  }\n\t  /**\n\t   * Returns the value of the control. If multiple items\n\t   * can be selected (e.g. <select multiple>), this returns\n\t   * an array. If only one item can be selected, this\n\t   * returns a string.\n\t   *\n\t   */\n\n\n\t  getValue() {\n\t    if (this.is_select_tag && this.input.hasAttribute('multiple')) {\n\t      return this.items;\n\t    }\n\n\t    return this.items.join(this.settings.delimiter);\n\t  }\n\t  /**\n\t   * Resets the selected items to the given value.\n\t   *\n\t   */\n\n\n\t  setValue(value, silent) {\n\t    var events = silent ? [] : ['change'];\n\t    debounce_events(this, events, () => {\n\t      this.clear(silent);\n\t      this.addItems(value, silent);\n\t    });\n\t  }\n\t  /**\n\t   * Resets the number of max items to the given value\n\t   *\n\t   */\n\n\n\t  setMaxItems(value) {\n\t    if (value === 0) value = null; //reset to unlimited items.\n\n\t    this.settings.maxItems = value;\n\t    this.refreshState();\n\t  }\n\t  /**\n\t   * Sets the selected item.\n\t   *\n\t   */\n\n\n\t  setActiveItem(item, e) {\n\t    var self = this;\n\t    var eventName;\n\t    var i, begin, end, swap;\n\t    var last;\n\t    if (self.settings.mode === 'single') return; // clear the active selection\n\n\t    if (!item) {\n\t      self.clearActiveItems();\n\n\t      if (self.isFocused) {\n\t        self.showInput();\n\t      }\n\n\t      return;\n\t    } // modify selection\n\n\n\t    eventName = e && e.type.toLowerCase();\n\n\t    if (eventName === 'click' && isKeyDown('shiftKey', e) && self.activeItems.length) {\n\t      last = self.getLastActive();\n\t      begin = Array.prototype.indexOf.call(self.control.children, last);\n\t      end = Array.prototype.indexOf.call(self.control.children, item);\n\n\t      if (begin > end) {\n\t        swap = begin;\n\t        begin = end;\n\t        end = swap;\n\t      }\n\n\t      for (i = begin; i <= end; i++) {\n\t        item = self.control.children[i];\n\n\t        if (self.activeItems.indexOf(item) === -1) {\n\t          self.setActiveItemClass(item);\n\t        }\n\t      }\n\n\t      preventDefault(e);\n\t    } else if (eventName === 'click' && isKeyDown(KEY_SHORTCUT, e) || eventName === 'keydown' && isKeyDown('shiftKey', e)) {\n\t      if (item.classList.contains('active')) {\n\t        self.removeActiveItem(item);\n\t      } else {\n\t        self.setActiveItemClass(item);\n\t      }\n\t    } else {\n\t      self.clearActiveItems();\n\t      self.setActiveItemClass(item);\n\t    } // ensure control has focus\n\n\n\t    self.hideInput();\n\n\t    if (!self.isFocused) {\n\t      self.focus();\n\t    }\n\t  }\n\t  /**\n\t   * Set the active and last-active classes\n\t   *\n\t   */\n\n\n\t  setActiveItemClass(item) {\n\t    const self = this;\n\t    const last_active = self.control.querySelector('.last-active');\n\t    if (last_active) removeClasses(last_active, 'last-active');\n\t    addClasses(item, 'active last-active');\n\t    self.trigger('item_select', item);\n\n\t    if (self.activeItems.indexOf(item) == -1) {\n\t      self.activeItems.push(item);\n\t    }\n\t  }\n\t  /**\n\t   * Remove active item\n\t   *\n\t   */\n\n\n\t  removeActiveItem(item) {\n\t    var idx = this.activeItems.indexOf(item);\n\t    this.activeItems.splice(idx, 1);\n\t    removeClasses(item, 'active');\n\t  }\n\t  /**\n\t   * Clears all the active items\n\t   *\n\t   */\n\n\n\t  clearActiveItems() {\n\t    removeClasses(this.activeItems, 'active');\n\t    this.activeItems = [];\n\t  }\n\t  /**\n\t   * Sets the selected item in the dropdown menu\n\t   * of available options.\n\t   *\n\t   */\n\n\n\t  setActiveOption(option, scroll = true) {\n\t    if (option === this.activeOption) {\n\t      return;\n\t    }\n\n\t    this.clearActiveOption();\n\t    if (!option) return;\n\t    this.activeOption = option;\n\t    setAttr(this.focus_node, {\n\t      'aria-activedescendant': option.getAttribute('id')\n\t    });\n\t    setAttr(option, {\n\t      'aria-selected': 'true'\n\t    });\n\t    addClasses(option, 'active');\n\t    if (scroll) this.scrollToOption(option);\n\t  }\n\t  /**\n\t   * Sets the dropdown_content scrollTop to display the option\n\t   *\n\t   */\n\n\n\t  scrollToOption(option, behavior) {\n\t    if (!option) return;\n\t    const content = this.dropdown_content;\n\t    const height_menu = content.clientHeight;\n\t    const scrollTop = content.scrollTop || 0;\n\t    const height_item = option.offsetHeight;\n\t    const y = option.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;\n\n\t    if (y + height_item > height_menu + scrollTop) {\n\t      this.scroll(y - height_menu + height_item, behavior);\n\t    } else if (y < scrollTop) {\n\t      this.scroll(y, behavior);\n\t    }\n\t  }\n\t  /**\n\t   * Scroll the dropdown to the given position\n\t   *\n\t   */\n\n\n\t  scroll(scrollTop, behavior) {\n\t    const content = this.dropdown_content;\n\n\t    if (behavior) {\n\t      content.style.scrollBehavior = behavior;\n\t    }\n\n\t    content.scrollTop = scrollTop;\n\t    content.style.scrollBehavior = '';\n\t  }\n\t  /**\n\t   * Clears the active option\n\t   *\n\t   */\n\n\n\t  clearActiveOption() {\n\t    if (this.activeOption) {\n\t      removeClasses(this.activeOption, 'active');\n\t      setAttr(this.activeOption, {\n\t        'aria-selected': null\n\t      });\n\t    }\n\n\t    this.activeOption = null;\n\t    setAttr(this.focus_node, {\n\t      'aria-activedescendant': null\n\t    });\n\t  }\n\t  /**\n\t   * Selects all items (CTRL + A).\n\t   */\n\n\n\t  selectAll() {\n\t    const self = this;\n\t    if (self.settings.mode === 'single') return;\n\t    const activeItems = self.controlChildren();\n\t    if (!activeItems.length) return;\n\t    self.hideInput();\n\t    self.close();\n\t    self.activeItems = activeItems;\n\t    iterate(activeItems, item => {\n\t      self.setActiveItemClass(item);\n\t    });\n\t  }\n\t  /**\n\t   * Determines if the control_input should be in a hidden or visible state\n\t   *\n\t   */\n\n\n\t  inputState() {\n\t    var self = this;\n\t    if (!self.control.contains(self.control_input)) return;\n\t    setAttr(self.control_input, {\n\t      placeholder: self.settings.placeholder\n\t    });\n\n\t    if (self.activeItems.length > 0 || !self.isFocused && self.settings.hidePlaceholder && self.items.length > 0) {\n\t      self.setTextboxValue();\n\t      self.isInputHidden = true;\n\t    } else {\n\t      if (self.settings.hidePlaceholder && self.items.length > 0) {\n\t        setAttr(self.control_input, {\n\t          placeholder: ''\n\t        });\n\t      }\n\n\t      self.isInputHidden = false;\n\t    }\n\n\t    self.wrapper.classList.toggle('input-hidden', self.isInputHidden);\n\t  }\n\t  /**\n\t   * Hides the input element out of view, while\n\t   * retaining its focus.\n\t   * @deprecated 1.3\n\t   */\n\n\n\t  hideInput() {\n\t    this.inputState();\n\t  }\n\t  /**\n\t   * Restores input visibility.\n\t   * @deprecated 1.3\n\t   */\n\n\n\t  showInput() {\n\t    this.inputState();\n\t  }\n\t  /**\n\t   * Get the input value\n\t   */\n\n\n\t  inputValue() {\n\t    return this.control_input.value.trim();\n\t  }\n\t  /**\n\t   * Gives the control focus.\n\t   */\n\n\n\t  focus() {\n\t    var self = this;\n\t    if (self.isDisabled) return;\n\t    self.ignoreFocus = true;\n\n\t    if (self.control_input.offsetWidth) {\n\t      self.control_input.focus();\n\t    } else {\n\t      self.focus_node.focus();\n\t    }\n\n\t    setTimeout(() => {\n\t      self.ignoreFocus = false;\n\t      self.onFocus();\n\t    }, 0);\n\t  }\n\t  /**\n\t   * Forces the control out of focus.\n\t   *\n\t   */\n\n\n\t  blur() {\n\t    this.focus_node.blur();\n\t    this.onBlur();\n\t  }\n\t  /**\n\t   * Returns a function that scores an object\n\t   * to show how good of a match it is to the\n\t   * provided query.\n\t   *\n\t   * @return {function}\n\t   */\n\n\n\t  getScoreFunction(query) {\n\t    return this.sifter.getScoreFunction(query, this.getSearchOptions());\n\t  }\n\t  /**\n\t   * Returns search options for sifter (the system\n\t   * for scoring and sorting results).\n\t   *\n\t   * @see https://github.com/orchidjs/sifter.js\n\t   * @return {object}\n\t   */\n\n\n\t  getSearchOptions() {\n\t    var settings = this.settings;\n\t    var sort = settings.sortField;\n\n\t    if (typeof settings.sortField === 'string') {\n\t      sort = [{\n\t        field: settings.sortField\n\t      }];\n\t    }\n\n\t    return {\n\t      fields: settings.searchField,\n\t      conjunction: settings.searchConjunction,\n\t      sort: sort,\n\t      nesting: settings.nesting\n\t    };\n\t  }\n\t  /**\n\t   * Searches through available options and returns\n\t   * a sorted array of matches.\n\t   *\n\t   */\n\n\n\t  search(query) {\n\t    var i, result, calculateScore;\n\t    var self = this;\n\t    var options = this.getSearchOptions(); // validate user-provided result scoring function\n\n\t    if (self.settings.score) {\n\t      calculateScore = self.settings.score.call(self, query);\n\n\t      if (typeof calculateScore !== 'function') {\n\t        throw new Error('Tom Select \"score\" setting must be a function that returns a function');\n\t      }\n\t    } // perform search\n\n\n\t    if (query !== self.lastQuery) {\n\t      self.lastQuery = query;\n\t      result = self.sifter.search(query, Object.assign(options, {\n\t        score: calculateScore\n\t      }));\n\t      self.currentResults = result;\n\t    } else {\n\t      result = Object.assign({}, self.currentResults);\n\t    } // filter out selected items\n\n\n\t    if (self.settings.hideSelected) {\n\t      for (i = result.items.length - 1; i >= 0; i--) {\n\t        let hashed = hash_key(result.items[i].id);\n\n\t        if (hashed && self.items.indexOf(hashed) !== -1) {\n\t          result.items.splice(i, 1);\n\t        }\n\t      }\n\t    }\n\n\t    return result;\n\t  }\n\t  /**\n\t   * Refreshes the list of available options shown\n\t   * in the autocomplete dropdown menu.\n\t   *\n\t   */\n\n\n\t  refreshOptions(triggerDropdown = true) {\n\t    var i, j, k, n, optgroup, optgroups, html, has_create_option, active_value, active_group;\n\t    var create;\n\t    const groups = {};\n\t    const groups_order = [];\n\t    var self = this;\n\t    var query = self.inputValue();\n\t    var results = self.search(query);\n\t    var active_option = null; //self.activeOption;\n\n\t    var show_dropdown = self.settings.shouldOpen || false;\n\t    var dropdown_content = self.dropdown_content;\n\n\t    if (self.activeOption) {\n\t      active_value = self.activeOption.dataset.value;\n\t      active_group = self.activeOption.closest('[data-group]');\n\t    } // build markup\n\n\n\t    n = results.items.length;\n\n\t    if (typeof self.settings.maxOptions === 'number') {\n\t      n = Math.min(n, self.settings.maxOptions);\n\t    }\n\n\t    if (n > 0) {\n\t      show_dropdown = true;\n\t    } // render and group available options individually\n\n\n\t    for (i = 0; i < n; i++) {\n\t      // get option dom element\n\t      let opt_value = results.items[i].id;\n\t      let option = self.options[opt_value];\n\t      let option_el = self.getOption(opt_value, true); // toggle 'selected' class\n\n\t      if (!self.settings.hideSelected) {\n\t        option_el.classList.toggle('selected', self.items.includes(opt_value));\n\t      }\n\n\t      optgroup = option[self.settings.optgroupField] || '';\n\t      optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];\n\n\t      for (j = 0, k = optgroups && optgroups.length; j < k; j++) {\n\t        optgroup = optgroups[j];\n\n\t        if (!self.optgroups.hasOwnProperty(optgroup)) {\n\t          optgroup = '';\n\t        }\n\n\t        if (!groups.hasOwnProperty(optgroup)) {\n\t          groups[optgroup] = document.createDocumentFragment();\n\t          groups_order.push(optgroup);\n\t        } // nodes can only have one parent, so if the option is in mutple groups, we need a clone\n\n\n\t        if (j > 0) {\n\t          option_el = option_el.cloneNode(true);\n\t          setAttr(option_el, {\n\t            id: option.$id + '-clone-' + j,\n\t            'aria-selected': null\n\t          });\n\t          option_el.classList.add('ts-cloned');\n\t          removeClasses(option_el, 'active');\n\t        } // make sure we keep the activeOption in the same group\n\n\n\t        if (!active_option && active_value == opt_value) {\n\t          if (active_group) {\n\t            if (active_group.dataset.group === optgroup) {\n\t              active_option = option_el;\n\t            }\n\t          } else {\n\t            active_option = option_el;\n\t          }\n\t        }\n\n\t        groups[optgroup].appendChild(option_el);\n\t      }\n\t    } // sort optgroups\n\n\n\t    if (this.settings.lockOptgroupOrder) {\n\t      groups_order.sort((a, b) => {\n\t        var a_order = self.optgroups[a] && self.optgroups[a].$order || 0;\n\t        var b_order = self.optgroups[b] && self.optgroups[b].$order || 0;\n\t        return a_order - b_order;\n\t      });\n\t    } // render optgroup headers & join groups\n\n\n\t    html = document.createDocumentFragment();\n\t    iterate(groups_order, optgroup => {\n\t      if (self.optgroups.hasOwnProperty(optgroup) && groups[optgroup].children.length) {\n\t        let group_options = document.createDocumentFragment();\n\t        let header = self.render('optgroup_header', self.optgroups[optgroup]);\n\t        append(group_options, header);\n\t        append(group_options, groups[optgroup]);\n\t        let group_html = self.render('optgroup', {\n\t          group: self.optgroups[optgroup],\n\t          options: group_options\n\t        });\n\t        append(html, group_html);\n\t      } else {\n\t        append(html, groups[optgroup]);\n\t      }\n\t    });\n\t    dropdown_content.innerHTML = '';\n\t    append(dropdown_content, html); // highlight matching terms inline\n\n\t    if (self.settings.highlight) {\n\t      removeHighlight(dropdown_content);\n\n\t      if (results.query.length && results.tokens.length) {\n\t        iterate(results.tokens, tok => {\n\t          highlight(dropdown_content, tok.regex);\n\t        });\n\t      }\n\t    } // helper method for adding templates to dropdown\n\n\n\t    var add_template = template => {\n\t      let content = self.render(template, {\n\t        input: query\n\t      });\n\n\t      if (content) {\n\t        show_dropdown = true;\n\t        dropdown_content.insertBefore(content, dropdown_content.firstChild);\n\t      }\n\n\t      return content;\n\t    }; // add loading message\n\n\n\t    if (self.loading) {\n\t      add_template('loading'); // invalid query\n\t    } else if (!self.settings.shouldLoad.call(self, query)) {\n\t      add_template('not_loading'); // add no_results message\n\t    } else if (results.items.length === 0) {\n\t      add_template('no_results');\n\t    } // add create option\n\n\n\t    has_create_option = self.canCreate(query);\n\n\t    if (has_create_option) {\n\t      create = add_template('option_create');\n\t    } // activate\n\n\n\t    self.hasOptions = results.items.length > 0 || has_create_option;\n\n\t    if (show_dropdown) {\n\t      if (results.items.length > 0) {\n\t        if (!active_option && self.settings.mode === 'single' && self.items.length) {\n\t          active_option = self.getOption(self.items[0]);\n\t        }\n\n\t        if (!dropdown_content.contains(active_option)) {\n\t          let active_index = 0;\n\n\t          if (create && !self.settings.addPrecedence) {\n\t            active_index = 1;\n\t          }\n\n\t          active_option = self.selectable()[active_index];\n\t        }\n\t      } else if (create) {\n\t        active_option = create;\n\t      }\n\n\t      if (triggerDropdown && !self.isOpen) {\n\t        self.open();\n\t        self.scrollToOption(active_option, 'auto');\n\t      }\n\n\t      self.setActiveOption(active_option);\n\t    } else {\n\t      self.clearActiveOption();\n\n\t      if (triggerDropdown && self.isOpen) {\n\t        self.close(false); // if create_option=null, we want the dropdown to close but not reset the textbox value\n\t      }\n\t    }\n\t  }\n\t  /**\n\t   * Return list of selectable options\n\t   *\n\t   */\n\n\n\t  selectable() {\n\t    return this.dropdown_content.querySelectorAll('[data-selectable]');\n\t  }\n\t  /**\n\t   * Adds an available option. If it already exists,\n\t   * nothing will happen. Note: this does not refresh\n\t   * the options list dropdown (use `refreshOptions`\n\t   * for that).\n\t   *\n\t   * Usage:\n\t   *\n\t   *   this.addOption(data)\n\t   *\n\t   */\n\n\n\t  addOption(data, user_created = false) {\n\t    const self = this; // @deprecated 1.7.7\n\t    // use addOptions( array, user_created ) for adding multiple options\n\n\t    if (Array.isArray(data)) {\n\t      self.addOptions(data, user_created);\n\t      return false;\n\t    }\n\n\t    const key = hash_key(data[self.settings.valueField]);\n\n\t    if (key === null || self.options.hasOwnProperty(key)) {\n\t      return false;\n\t    }\n\n\t    data.$order = data.$order || ++self.order;\n\t    data.$id = self.inputId + '-opt-' + data.$order;\n\t    self.options[key] = data;\n\t    self.lastQuery = null;\n\n\t    if (user_created) {\n\t      self.userOptions[key] = user_created;\n\t      self.trigger('option_add', key, data);\n\t    }\n\n\t    return key;\n\t  }\n\t  /**\n\t   * Add multiple options\n\t   *\n\t   */\n\n\n\t  addOptions(data, user_created = false) {\n\t    iterate(data, dat => {\n\t      this.addOption(dat, user_created);\n\t    });\n\t  }\n\t  /**\n\t   * @deprecated 1.7.7\n\t   */\n\n\n\t  registerOption(data) {\n\t    return this.addOption(data);\n\t  }\n\t  /**\n\t   * Registers an option group to the pool of option groups.\n\t   *\n\t   * @return {boolean|string}\n\t   */\n\n\n\t  registerOptionGroup(data) {\n\t    var key = hash_key(data[this.settings.optgroupValueField]);\n\t    if (key === null) return false;\n\t    data.$order = data.$order || ++this.order;\n\t    this.optgroups[key] = data;\n\t    return key;\n\t  }\n\t  /**\n\t   * Registers a new optgroup for options\n\t   * to be bucketed into.\n\t   *\n\t   */\n\n\n\t  addOptionGroup(id, data) {\n\t    var hashed_id;\n\t    data[this.settings.optgroupValueField] = id;\n\n\t    if (hashed_id = this.registerOptionGroup(data)) {\n\t      this.trigger('optgroup_add', hashed_id, data);\n\t    }\n\t  }\n\t  /**\n\t   * Removes an existing option group.\n\t   *\n\t   */\n\n\n\t  removeOptionGroup(id) {\n\t    if (this.optgroups.hasOwnProperty(id)) {\n\t      delete this.optgroups[id];\n\t      this.clearCache();\n\t      this.trigger('optgroup_remove', id);\n\t    }\n\t  }\n\t  /**\n\t   * Clears all existing option groups.\n\t   */\n\n\n\t  clearOptionGroups() {\n\t    this.optgroups = {};\n\t    this.clearCache();\n\t    this.trigger('optgroup_clear');\n\t  }\n\t  /**\n\t   * Updates an option available for selection. If\n\t   * it is visible in the selected items or options\n\t   * dropdown, it will be re-rendered automatically.\n\t   *\n\t   */\n\n\n\t  updateOption(value, data) {\n\t    const self = this;\n\t    var item_new;\n\t    var index_item;\n\t    const value_old = hash_key(value);\n\t    const value_new = hash_key(data[self.settings.valueField]); // sanity checks\n\n\t    if (value_old === null) return;\n\t    if (!self.options.hasOwnProperty(value_old)) return;\n\t    if (typeof value_new !== 'string') throw new Error('Value must be set in option data');\n\t    const option = self.getOption(value_old);\n\t    const item = self.getItem(value_old);\n\t    data.$order = data.$order || self.options[value_old].$order;\n\t    delete self.options[value_old]; // invalidate render cache\n\t    // don't remove existing node yet, we'll remove it after replacing it\n\n\t    self.uncacheValue(value_new);\n\t    self.options[value_new] = data; // update the option if it's in the dropdown\n\n\t    if (option) {\n\t      if (self.dropdown_content.contains(option)) {\n\t        const option_new = self._render('option', data);\n\n\t        replaceNode(option, option_new);\n\n\t        if (self.activeOption === option) {\n\t          self.setActiveOption(option_new);\n\t        }\n\t      }\n\n\t      option.remove();\n\t    } // update the item if we have one\n\n\n\t    if (item) {\n\t      index_item = self.items.indexOf(value_old);\n\n\t      if (index_item !== -1) {\n\t        self.items.splice(index_item, 1, value_new);\n\t      }\n\n\t      item_new = self._render('item', data);\n\t      if (item.classList.contains('active')) addClasses(item_new, 'active');\n\t      replaceNode(item, item_new);\n\t    } // invalidate last query because we might have updated the sortField\n\n\n\t    self.lastQuery = null;\n\t  }\n\t  /**\n\t   * Removes a single option.\n\t   *\n\t   */\n\n\n\t  removeOption(value, silent) {\n\t    const self = this;\n\t    value = get_hash(value);\n\t    self.uncacheValue(value);\n\t    delete self.userOptions[value];\n\t    delete self.options[value];\n\t    self.lastQuery = null;\n\t    self.trigger('option_remove', value);\n\t    self.removeItem(value, silent);\n\t  }\n\t  /**\n\t   * Clears all options.\n\t   */\n\n\n\t  clearOptions(filter) {\n\t    const boundFilter = (filter || this.clearFilter).bind(this);\n\t    this.loadedSearches = {};\n\t    this.userOptions = {};\n\t    this.clearCache();\n\t    const selected = {};\n\t    iterate(this.options, (option, key) => {\n\t      if (boundFilter(option, key)) {\n\t        selected[key] = this.options[key];\n\t      }\n\t    });\n\t    this.options = this.sifter.items = selected;\n\t    this.lastQuery = null;\n\t    this.trigger('option_clear');\n\t  }\n\t  /**\n\t   * Used by clearOptions() to decide whether or not an option should be removed\n\t   * Return true to keep an option, false to remove\n\t   *\n\t   */\n\n\n\t  clearFilter(option, value) {\n\t    if (this.items.indexOf(value) >= 0) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\t  /**\n\t   * Returns the dom element of the option\n\t   * matching the given value.\n\t   *\n\t   */\n\n\n\t  getOption(value, create = false) {\n\t    const hashed = hash_key(value);\n\n\t    if (hashed !== null && this.options.hasOwnProperty(hashed)) {\n\t      const option = this.options[hashed];\n\n\t      if (option.$div) {\n\t        return option.$div;\n\t      }\n\n\t      if (create) {\n\t        return this._render('option', option);\n\t      }\n\t    }\n\n\t    return null;\n\t  }\n\t  /**\n\t   * Returns the dom element of the next or previous dom element of the same type\n\t   * Note: adjacent options may not be adjacent DOM elements (optgroups)\n\t   *\n\t   */\n\n\n\t  getAdjacent(option, direction, type = 'option') {\n\t    var self = this,\n\t        all;\n\n\t    if (!option) {\n\t      return null;\n\t    }\n\n\t    if (type == 'item') {\n\t      all = self.controlChildren();\n\t    } else {\n\t      all = self.dropdown_content.querySelectorAll('[data-selectable]');\n\t    }\n\n\t    for (let i = 0; i < all.length; i++) {\n\t      if (all[i] != option) {\n\t        continue;\n\t      }\n\n\t      if (direction > 0) {\n\t        return all[i + 1];\n\t      }\n\n\t      return all[i - 1];\n\t    }\n\n\t    return null;\n\t  }\n\t  /**\n\t   * Returns the dom element of the item\n\t   * matching the given value.\n\t   *\n\t   */\n\n\n\t  getItem(item) {\n\t    if (typeof item == 'object') {\n\t      return item;\n\t    }\n\n\t    var value = hash_key(item);\n\t    return value !== null ? this.control.querySelector(`[data-value=\"${addSlashes(value)}\"]`) : null;\n\t  }\n\t  /**\n\t   * \"Selects\" multiple items at once. Adds them to the list\n\t   * at the current caret position.\n\t   *\n\t   */\n\n\n\t  addItems(values, silent) {\n\t    var self = this;\n\t    var items = Array.isArray(values) ? values : [values];\n\t    items = items.filter(x => self.items.indexOf(x) === -1);\n\n\t    for (let i = 0, n = items.length; i < n; i++) {\n\t      self.isPending = i < n - 1;\n\t      self.addItem(items[i], silent);\n\t    }\n\t  }\n\t  /**\n\t   * \"Selects\" an item. Adds it to the list\n\t   * at the current caret position.\n\t   *\n\t   */\n\n\n\t  addItem(value, silent) {\n\t    var events = silent ? [] : ['change', 'dropdown_close'];\n\t    debounce_events(this, events, () => {\n\t      var item, wasFull;\n\t      const self = this;\n\t      const inputMode = self.settings.mode;\n\t      const hashed = hash_key(value);\n\n\t      if (hashed && self.items.indexOf(hashed) !== -1) {\n\t        if (inputMode === 'single') {\n\t          self.close();\n\t        }\n\n\t        if (inputMode === 'single' || !self.settings.duplicates) {\n\t          return;\n\t        }\n\t      }\n\n\t      if (hashed === null || !self.options.hasOwnProperty(hashed)) return;\n\t      if (inputMode === 'single') self.clear(silent);\n\t      if (inputMode === 'multi' && self.isFull()) return;\n\t      item = self._render('item', self.options[hashed]);\n\n\t      if (self.control.contains(item)) {\n\t        // duplicates\n\t        item = item.cloneNode(true);\n\t      }\n\n\t      wasFull = self.isFull();\n\t      self.items.splice(self.caretPos, 0, hashed);\n\t      self.insertAtCaret(item);\n\n\t      if (self.isSetup) {\n\t        // update menu / remove the option (if this is not one item being added as part of series)\n\t        if (!self.isPending && self.settings.hideSelected) {\n\t          let option = self.getOption(hashed);\n\t          let next = self.getAdjacent(option, 1);\n\n\t          if (next) {\n\t            self.setActiveOption(next);\n\t          }\n\t        } // refreshOptions after setActiveOption(),\n\t        // otherwise setActiveOption() will be called by refreshOptions() with the wrong value\n\n\n\t        if (!self.isPending && !self.settings.closeAfterSelect) {\n\t          self.refreshOptions(self.isFocused && inputMode !== 'single');\n\t        } // hide the menu if the maximum number of items have been selected or no options are left\n\n\n\t        if (self.settings.closeAfterSelect != false && self.isFull()) {\n\t          self.close();\n\t        } else if (!self.isPending) {\n\t          self.positionDropdown();\n\t        }\n\n\t        self.trigger('item_add', hashed, item);\n\n\t        if (!self.isPending) {\n\t          self.updateOriginalInput({\n\t            silent: silent\n\t          });\n\t        }\n\t      }\n\n\t      if (!self.isPending || !wasFull && self.isFull()) {\n\t        self.inputState();\n\t        self.refreshState();\n\t      }\n\t    });\n\t  }\n\t  /**\n\t   * Removes the selected item matching\n\t   * the provided value.\n\t   *\n\t   */\n\n\n\t  removeItem(item = null, silent) {\n\t    const self = this;\n\t    item = self.getItem(item);\n\t    if (!item) return;\n\t    var i, idx;\n\t    const value = item.dataset.value;\n\t    i = nodeIndex(item);\n\t    item.remove();\n\n\t    if (item.classList.contains('active')) {\n\t      idx = self.activeItems.indexOf(item);\n\t      self.activeItems.splice(idx, 1);\n\t      removeClasses(item, 'active');\n\t    }\n\n\t    self.items.splice(i, 1);\n\t    self.lastQuery = null;\n\n\t    if (!self.settings.persist && self.userOptions.hasOwnProperty(value)) {\n\t      self.removeOption(value, silent);\n\t    }\n\n\t    if (i < self.caretPos) {\n\t      self.setCaret(self.caretPos - 1);\n\t    }\n\n\t    self.updateOriginalInput({\n\t      silent: silent\n\t    });\n\t    self.refreshState();\n\t    self.positionDropdown();\n\t    self.trigger('item_remove', value, item);\n\t  }\n\t  /**\n\t   * Invokes the `create` method provided in the\n\t   * TomSelect options that should provide the data\n\t   * for the new item, given the user input.\n\t   *\n\t   * Once this completes, it will be added\n\t   * to the item list.\n\t   *\n\t   */\n\n\n\t  createItem(input = null, triggerDropdown = true, callback = () => {}) {\n\t    var self = this;\n\t    var caret = self.caretPos;\n\t    var output;\n\t    input = input || self.inputValue();\n\n\t    if (!self.canCreate(input)) {\n\t      callback();\n\t      return false;\n\t    }\n\n\t    self.lock();\n\t    var created = false;\n\n\t    var create = data => {\n\t      self.unlock();\n\t      if (!data || typeof data !== 'object') return callback();\n\t      var value = hash_key(data[self.settings.valueField]);\n\n\t      if (typeof value !== 'string') {\n\t        return callback();\n\t      }\n\n\t      self.setTextboxValue();\n\t      self.addOption(data, true);\n\t      self.setCaret(caret);\n\t      self.addItem(value);\n\t      callback(data);\n\t      created = true;\n\t    };\n\n\t    if (typeof self.settings.create === 'function') {\n\t      output = self.settings.create.call(this, input, create);\n\t    } else {\n\t      output = {\n\t        [self.settings.labelField]: input,\n\t        [self.settings.valueField]: input\n\t      };\n\t    }\n\n\t    if (!created) {\n\t      create(output);\n\t    }\n\n\t    return true;\n\t  }\n\t  /**\n\t   * Re-renders the selected item lists.\n\t   */\n\n\n\t  refreshItems() {\n\t    var self = this;\n\t    self.lastQuery = null;\n\n\t    if (self.isSetup) {\n\t      self.addItems(self.items);\n\t    }\n\n\t    self.updateOriginalInput();\n\t    self.refreshState();\n\t  }\n\t  /**\n\t   * Updates all state-dependent attributes\n\t   * and CSS classes.\n\t   */\n\n\n\t  refreshState() {\n\t    const self = this;\n\t    self.refreshValidityState();\n\t    const isFull = self.isFull();\n\t    const isLocked = self.isLocked;\n\t    self.wrapper.classList.toggle('rtl', self.rtl);\n\t    const wrap_classList = self.wrapper.classList;\n\t    wrap_classList.toggle('focus', self.isFocused);\n\t    wrap_classList.toggle('disabled', self.isDisabled);\n\t    wrap_classList.toggle('required', self.isRequired);\n\t    wrap_classList.toggle('invalid', !self.isValid);\n\t    wrap_classList.toggle('locked', isLocked);\n\t    wrap_classList.toggle('full', isFull);\n\t    wrap_classList.toggle('input-active', self.isFocused && !self.isInputHidden);\n\t    wrap_classList.toggle('dropdown-active', self.isOpen);\n\t    wrap_classList.toggle('has-options', isEmptyObject(self.options));\n\t    wrap_classList.toggle('has-items', self.items.length > 0);\n\t  }\n\t  /**\n\t   * Update the `required` attribute of both input and control input.\n\t   *\n\t   * The `required` property needs to be activated on the control input\n\t   * for the error to be displayed at the right place. `required` also\n\t   * needs to be temporarily deactivated on the input since the input is\n\t   * hidden and can't show errors.\n\t   */\n\n\n\t  refreshValidityState() {\n\t    var self = this;\n\n\t    if (!self.input.validity) {\n\t      return;\n\t    }\n\n\t    self.isValid = self.input.validity.valid;\n\t    self.isInvalid = !self.isValid;\n\t  }\n\t  /**\n\t   * Determines whether or not more items can be added\n\t   * to the control without exceeding the user-defined maximum.\n\t   *\n\t   * @returns {boolean}\n\t   */\n\n\n\t  isFull() {\n\t    return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;\n\t  }\n\t  /**\n\t   * Refreshes the original <select> or <input>\n\t   * element to reflect the current state.\n\t   *\n\t   */\n\n\n\t  updateOriginalInput(opts = {}) {\n\t    const self = this;\n\t    var option, label;\n\t    const empty_option = self.input.querySelector('option[value=\"\"]');\n\n\t    if (self.is_select_tag) {\n\t      const selected = [];\n\t      const has_selected = self.input.querySelectorAll('option:checked').length;\n\n\t      function AddSelected(option_el, value, label) {\n\t        if (!option_el) {\n\t          option_el = getDom('<option value=\"' + escape_html(value) + '\">' + escape_html(label) + '</option>');\n\t        } // don't move empty option from top of list\n\t        // fixes bug in firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1725293\n\n\n\t        if (option_el != empty_option) {\n\t          self.input.append(option_el);\n\t        }\n\n\t        selected.push(option_el); // marking empty option as selected can break validation\n\t        // fixes https://github.com/orchidjs/tom-select/issues/303\n\n\t        if (option_el != empty_option || has_selected > 0) {\n\t          option_el.selected = true;\n\t        }\n\n\t        return option_el;\n\t      } // unselect all selected options\n\n\n\t      self.input.querySelectorAll('option:checked').forEach(option_el => {\n\t        option_el.selected = false;\n\t      }); // nothing selected?\n\n\t      if (self.items.length == 0 && self.settings.mode == 'single') {\n\t        AddSelected(empty_option, \"\", \"\"); // order selected <option> tags for values in self.items\n\t      } else {\n\t        self.items.forEach(value => {\n\t          option = self.options[value];\n\t          label = option[self.settings.labelField] || '';\n\n\t          if (selected.includes(option.$option)) {\n\t            const reuse_opt = self.input.querySelector(`option[value=\"${addSlashes(value)}\"]:not(:checked)`);\n\t            AddSelected(reuse_opt, value, label);\n\t          } else {\n\t            option.$option = AddSelected(option.$option, value, label);\n\t          }\n\t        });\n\t      }\n\t    } else {\n\t      self.input.value = self.getValue();\n\t    }\n\n\t    if (self.isSetup) {\n\t      if (!opts.silent) {\n\t        self.trigger('change', self.getValue());\n\t      }\n\t    }\n\t  }\n\t  /**\n\t   * Shows the autocomplete dropdown containing\n\t   * the available options.\n\t   */\n\n\n\t  open() {\n\t    var self = this;\n\t    if (self.isLocked || self.isOpen || self.settings.mode === 'multi' && self.isFull()) return;\n\t    self.isOpen = true;\n\t    setAttr(self.focus_node, {\n\t      'aria-expanded': 'true'\n\t    });\n\t    self.refreshState();\n\t    applyCSS(self.dropdown, {\n\t      visibility: 'hidden',\n\t      display: 'block'\n\t    });\n\t    self.positionDropdown();\n\t    applyCSS(self.dropdown, {\n\t      visibility: 'visible',\n\t      display: 'block'\n\t    });\n\t    self.focus();\n\t    self.trigger('dropdown_open', self.dropdown);\n\t  }\n\t  /**\n\t   * Closes the autocomplete dropdown menu.\n\t   */\n\n\n\t  close(setTextboxValue = true) {\n\t    var self = this;\n\t    var trigger = self.isOpen;\n\n\t    if (setTextboxValue) {\n\t      // before blur() to prevent form onchange event\n\t      self.setTextboxValue();\n\n\t      if (self.settings.mode === 'single' && self.items.length) {\n\t        self.hideInput();\n\t      }\n\t    }\n\n\t    self.isOpen = false;\n\t    setAttr(self.focus_node, {\n\t      'aria-expanded': 'false'\n\t    });\n\t    applyCSS(self.dropdown, {\n\t      display: 'none'\n\t    });\n\n\t    if (self.settings.hideSelected) {\n\t      self.clearActiveOption();\n\t    }\n\n\t    self.refreshState();\n\t    if (trigger) self.trigger('dropdown_close', self.dropdown);\n\t  }\n\t  /**\n\t   * Calculates and applies the appropriate\n\t   * position of the dropdown if dropdownParent = 'body'.\n\t   * Otherwise, position is determined by css\n\t   */\n\n\n\t  positionDropdown() {\n\t    if (this.settings.dropdownParent !== 'body') {\n\t      return;\n\t    }\n\n\t    var context = this.control;\n\t    var rect = context.getBoundingClientRect();\n\t    var top = context.offsetHeight + rect.top + window.scrollY;\n\t    var left = rect.left + window.scrollX;\n\t    applyCSS(this.dropdown, {\n\t      width: rect.width + 'px',\n\t      top: top + 'px',\n\t      left: left + 'px'\n\t    });\n\t  }\n\t  /**\n\t   * Resets / clears all selected items\n\t   * from the control.\n\t   *\n\t   */\n\n\n\t  clear(silent) {\n\t    var self = this;\n\t    if (!self.items.length) return;\n\t    var items = self.controlChildren();\n\t    iterate(items, item => {\n\t      self.removeItem(item, true);\n\t    });\n\t    self.showInput();\n\t    if (!silent) self.updateOriginalInput();\n\t    self.trigger('clear');\n\t  }\n\t  /**\n\t   * A helper method for inserting an element\n\t   * at the current caret position.\n\t   *\n\t   */\n\n\n\t  insertAtCaret(el) {\n\t    const self = this;\n\t    const caret = self.caretPos;\n\t    const target = self.control;\n\t    target.insertBefore(el, target.children[caret]);\n\t    self.setCaret(caret + 1);\n\t  }\n\t  /**\n\t   * Removes the current selected item(s).\n\t   *\n\t   */\n\n\n\t  deleteSelection(e) {\n\t    var direction, selection, caret, tail;\n\t    var self = this;\n\t    direction = e && e.keyCode === KEY_BACKSPACE ? -1 : 1;\n\t    selection = getSelection(self.control_input); // determine items that will be removed\n\n\t    const rm_items = [];\n\n\t    if (self.activeItems.length) {\n\t      tail = getTail(self.activeItems, direction);\n\t      caret = nodeIndex(tail);\n\n\t      if (direction > 0) {\n\t        caret++;\n\t      }\n\n\t      iterate(self.activeItems, item => rm_items.push(item));\n\t    } else if ((self.isFocused || self.settings.mode === 'single') && self.items.length) {\n\t      const items = self.controlChildren();\n\n\t      if (direction < 0 && selection.start === 0 && selection.length === 0) {\n\t        rm_items.push(items[self.caretPos - 1]);\n\t      } else if (direction > 0 && selection.start === self.inputValue().length) {\n\t        rm_items.push(items[self.caretPos]);\n\t      }\n\t    }\n\n\t    if (!self.shouldDelete(rm_items, e)) {\n\t      return false;\n\t    }\n\n\t    preventDefault(e, true); // perform removal\n\n\t    if (typeof caret !== 'undefined') {\n\t      self.setCaret(caret);\n\t    }\n\n\t    while (rm_items.length) {\n\t      self.removeItem(rm_items.pop());\n\t    }\n\n\t    self.showInput();\n\t    self.positionDropdown();\n\t    self.refreshOptions(false);\n\t    return true;\n\t  }\n\t  /**\n\t   * Return true if the items should be deleted\n\t   */\n\n\n\t  shouldDelete(items, evt) {\n\t    const values = items.map(item => item.dataset.value); // allow the callback to abort\n\n\t    if (!values.length || typeof this.settings.onDelete === 'function' && this.settings.onDelete(values, evt) === false) {\n\t      return false;\n\t    }\n\n\t    return true;\n\t  }\n\t  /**\n\t   * Selects the previous / next item (depending on the `direction` argument).\n\t   *\n\t   * > 0 - right\n\t   * < 0 - left\n\t   *\n\t   */\n\n\n\t  advanceSelection(direction, e) {\n\t    var last_active,\n\t        adjacent,\n\t        self = this;\n\t    if (self.rtl) direction *= -1;\n\t    if (self.inputValue().length) return; // add or remove to active items\n\n\t    if (isKeyDown(KEY_SHORTCUT, e) || isKeyDown('shiftKey', e)) {\n\t      last_active = self.getLastActive(direction);\n\n\t      if (last_active) {\n\t        if (!last_active.classList.contains('active')) {\n\t          adjacent = last_active;\n\t        } else {\n\t          adjacent = self.getAdjacent(last_active, direction, 'item');\n\t        } // if no active item, get items adjacent to the control input\n\n\t      } else if (direction > 0) {\n\t        adjacent = self.control_input.nextElementSibling;\n\t      } else {\n\t        adjacent = self.control_input.previousElementSibling;\n\t      }\n\n\t      if (adjacent) {\n\t        if (adjacent.classList.contains('active')) {\n\t          self.removeActiveItem(last_active);\n\t        }\n\n\t        self.setActiveItemClass(adjacent); // mark as last_active !! after removeActiveItem() on last_active\n\t      } // move caret to the left or right\n\n\t    } else {\n\t      self.moveCaret(direction);\n\t    }\n\t  }\n\n\t  moveCaret(direction) {}\n\t  /**\n\t   * Get the last active item\n\t   *\n\t   */\n\n\n\t  getLastActive(direction) {\n\t    let last_active = this.control.querySelector('.last-active');\n\n\t    if (last_active) {\n\t      return last_active;\n\t    }\n\n\t    var result = this.control.querySelectorAll('.active');\n\n\t    if (result) {\n\t      return getTail(result, direction);\n\t    }\n\t  }\n\t  /**\n\t   * Moves the caret to the specified index.\n\t   *\n\t   * The input must be moved by leaving it in place and moving the\n\t   * siblings, due to the fact that focus cannot be restored once lost\n\t   * on mobile webkit devices\n\t   *\n\t   */\n\n\n\t  setCaret(new_pos) {\n\t    this.caretPos = this.items.length;\n\t  }\n\t  /**\n\t   * Return list of item dom elements\n\t   *\n\t   */\n\n\n\t  controlChildren() {\n\t    return Array.from(this.control.querySelectorAll('[data-ts-item]'));\n\t  }\n\t  /**\n\t   * Disables user input on the control. Used while\n\t   * items are being asynchronously created.\n\t   */\n\n\n\t  lock() {\n\t    this.isLocked = true;\n\t    this.refreshState();\n\t  }\n\t  /**\n\t   * Re-enables user input on the control.\n\t   */\n\n\n\t  unlock() {\n\t    this.isLocked = false;\n\t    this.refreshState();\n\t  }\n\t  /**\n\t   * Disables user input on the control completely.\n\t   * While disabled, it cannot receive focus.\n\t   */\n\n\n\t  disable() {\n\t    var self = this;\n\t    self.input.disabled = true;\n\t    self.control_input.disabled = true;\n\t    self.focus_node.tabIndex = -1;\n\t    self.isDisabled = true;\n\t    this.close();\n\t    self.lock();\n\t  }\n\t  /**\n\t   * Enables the control so that it can respond\n\t   * to focus and user input.\n\t   */\n\n\n\t  enable() {\n\t    var self = this;\n\t    self.input.disabled = false;\n\t    self.control_input.disabled = false;\n\t    self.focus_node.tabIndex = self.tabIndex;\n\t    self.isDisabled = false;\n\t    self.unlock();\n\t  }\n\t  /**\n\t   * Completely destroys the control and\n\t   * unbinds all event listeners so that it can\n\t   * be garbage collected.\n\t   */\n\n\n\t  destroy() {\n\t    var self = this;\n\t    var revertSettings = self.revertSettings;\n\t    self.trigger('destroy');\n\t    self.off();\n\t    self.wrapper.remove();\n\t    self.dropdown.remove();\n\t    self.input.innerHTML = revertSettings.innerHTML;\n\t    self.input.tabIndex = revertSettings.tabIndex;\n\t    removeClasses(self.input, 'tomselected', 'ts-hidden-accessible');\n\n\t    self._destroy();\n\n\t    delete self.input.tomselect;\n\t  }\n\t  /**\n\t   * A helper method for rendering \"item\" and\n\t   * \"option\" templates, given the data.\n\t   *\n\t   */\n\n\n\t  render(templateName, data) {\n\t    if (typeof this.settings.render[templateName] !== 'function') {\n\t      return null;\n\t    }\n\n\t    return this._render(templateName, data);\n\t  }\n\t  /**\n\t   * _render() can be called directly when we know we don't want to hit the cache\n\t   * return type could be null for some templates, we need https://github.com/microsoft/TypeScript/issues/33014\n\t   */\n\n\n\t  _render(templateName, data) {\n\t    var value = '',\n\t        id,\n\t        html;\n\t    const self = this;\n\n\t    if (templateName === 'option' || templateName == 'item') {\n\t      value = get_hash(data[self.settings.valueField]);\n\t    } // render markup\n\n\n\t    html = self.settings.render[templateName].call(this, data, escape_html);\n\n\t    if (html == null) {\n\t      return html;\n\t    }\n\n\t    html = getDom(html); // add mandatory attributes\n\n\t    if (templateName === 'option' || templateName === 'option_create') {\n\t      if (data[self.settings.disabledField]) {\n\t        setAttr(html, {\n\t          'aria-disabled': 'true'\n\t        });\n\t      } else {\n\t        setAttr(html, {\n\t          'data-selectable': ''\n\t        });\n\t      }\n\t    } else if (templateName === 'optgroup') {\n\t      id = data.group[self.settings.optgroupValueField];\n\t      setAttr(html, {\n\t        'data-group': id\n\t      });\n\n\t      if (data.group[self.settings.disabledField]) {\n\t        setAttr(html, {\n\t          'data-disabled': ''\n\t        });\n\t      }\n\t    }\n\n\t    if (templateName === 'option' || templateName === 'item') {\n\t      setAttr(html, {\n\t        'data-value': value\n\t      }); // make sure we have some classes if a template is overwritten\n\n\t      if (templateName === 'item') {\n\t        addClasses(html, self.settings.itemClass);\n\t        setAttr(html, {\n\t          'data-ts-item': ''\n\t        });\n\t      } else {\n\t        addClasses(html, self.settings.optionClass);\n\t        setAttr(html, {\n\t          role: 'option',\n\t          id: data.$id\n\t        }); // update cache\n\n\t        self.options[value].$div = html;\n\t      }\n\t    }\n\n\t    return html;\n\t  }\n\t  /**\n\t   * Clears the render cache for a template. If\n\t   * no template is given, clears all render\n\t   * caches.\n\t   *\n\t   */\n\n\n\t  clearCache() {\n\t    iterate(this.options, (option, value) => {\n\t      if (option.$div) {\n\t        option.$div.remove();\n\t        delete option.$div;\n\t      }\n\t    });\n\t  }\n\t  /**\n\t   * Removes a value from item and option caches\n\t   *\n\t   */\n\n\n\t  uncacheValue(value) {\n\t    const option_el = this.getOption(value);\n\t    if (option_el) option_el.remove();\n\t  }\n\t  /**\n\t   * Determines whether or not to display the\n\t   * create item prompt, given a user input.\n\t   *\n\t   */\n\n\n\t  canCreate(input) {\n\t    return this.settings.create && input.length > 0 && this.settings.createFilter.call(this, input);\n\t  }\n\t  /**\n\t   * Wraps this.`method` so that `new_fn` can be invoked 'before', 'after', or 'instead' of the original method\n\t   *\n\t   * this.hook('instead','onKeyDown',function( arg1, arg2 ...){\n\t   *\n\t   * });\n\t   */\n\n\n\t  hook(when, method, new_fn) {\n\t    var self = this;\n\t    var orig_method = self[method];\n\n\t    self[method] = function () {\n\t      var result, result_new;\n\n\t      if (when === 'after') {\n\t        result = orig_method.apply(self, arguments);\n\t      }\n\n\t      result_new = new_fn.apply(self, arguments);\n\n\t      if (when === 'instead') {\n\t        return result_new;\n\t      }\n\n\t      if (when === 'before') {\n\t        result = orig_method.apply(self, arguments);\n\t      }\n\n\t      return result;\n\t    };\n\t  }\n\n\t}\n\n\t/**\n\t * Plugin: \"change_listener\" (Tom Select)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction change_listener () {\n\t  addEvent(this.input, 'change', () => {\n\t    this.sync();\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"restore_on_backspace\" (Tom Select)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction checkbox_options () {\n\t  var self = this;\n\t  var orig_onOptionSelect = self.onOptionSelect;\n\t  self.settings.hideSelected = false; // update the checkbox for an option\n\n\t  var UpdateCheckbox = function UpdateCheckbox(option) {\n\t    setTimeout(() => {\n\t      var checkbox = option.querySelector('input');\n\n\t      if (checkbox instanceof HTMLInputElement) {\n\t        if (option.classList.contains('selected')) {\n\t          checkbox.checked = true;\n\t        } else {\n\t          checkbox.checked = false;\n\t        }\n\t      }\n\t    }, 1);\n\t  }; // add checkbox to option template\n\n\n\t  self.hook('after', 'setupTemplates', () => {\n\t    var orig_render_option = self.settings.render.option;\n\n\t    self.settings.render.option = (data, escape_html) => {\n\t      var rendered = getDom(orig_render_option.call(self, data, escape_html));\n\t      var checkbox = document.createElement('input');\n\t      checkbox.addEventListener('click', function (evt) {\n\t        preventDefault(evt);\n\t      });\n\t      checkbox.type = 'checkbox';\n\t      const hashed = hash_key(data[self.settings.valueField]);\n\n\t      if (hashed && self.items.indexOf(hashed) > -1) {\n\t        checkbox.checked = true;\n\t      }\n\n\t      rendered.prepend(checkbox);\n\t      return rendered;\n\t    };\n\t  }); // uncheck when item removed\n\n\t  self.on('item_remove', value => {\n\t    var option = self.getOption(value);\n\n\t    if (option) {\n\t      // if dropdown hasn't been opened yet, the option won't exist\n\t      option.classList.remove('selected'); // selected class won't be removed yet\n\n\t      UpdateCheckbox(option);\n\t    }\n\t  }); // check when item added\n\n\t  self.on('item_add', value => {\n\t    var option = self.getOption(value);\n\n\t    if (option) {\n\t      // if dropdown hasn't been opened yet, the option won't exist\n\t      UpdateCheckbox(option);\n\t    }\n\t  }); // remove items when selected option is clicked\n\n\t  self.hook('instead', 'onOptionSelect', (evt, option) => {\n\t    if (option.classList.contains('selected')) {\n\t      option.classList.remove('selected');\n\t      self.removeItem(option.dataset.value);\n\t      self.refreshOptions();\n\t      preventDefault(evt, true);\n\t      return;\n\t    }\n\n\t    orig_onOptionSelect.call(self, evt, option);\n\t    UpdateCheckbox(option);\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"dropdown_header\" (Tom Select)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction clear_button (userOptions) {\n\t  const self = this;\n\t  const options = Object.assign({\n\t    className: 'clear-button',\n\t    title: 'Clear All',\n\t    html: data => {\n\t      return `<div class=\"${data.className}\" title=\"${data.title}\">&times;</div>`;\n\t    }\n\t  }, userOptions);\n\t  self.on('initialize', () => {\n\t    var button = getDom(options.html(options));\n\t    button.addEventListener('click', evt => {\n\t      if (self.isDisabled) {\n\t        return;\n\t      }\n\n\t      self.clear();\n\n\t      if (self.settings.mode === 'single' && self.settings.allowEmptyOption) {\n\t        self.addItem('');\n\t      }\n\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t    });\n\t    self.control.appendChild(button);\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"drag_drop\" (Tom Select)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction drag_drop () {\n\t  var self = this;\n\t  if (!$.fn.sortable) throw new Error('The \"drag_drop\" plugin requires jQuery UI \"sortable\".');\n\t  if (self.settings.mode !== 'multi') return;\n\t  var orig_lock = self.lock;\n\t  var orig_unlock = self.unlock;\n\t  self.hook('instead', 'lock', () => {\n\t    var sortable = $(self.control).data('sortable');\n\t    if (sortable) sortable.disable();\n\t    return orig_lock.call(self);\n\t  });\n\t  self.hook('instead', 'unlock', () => {\n\t    var sortable = $(self.control).data('sortable');\n\t    if (sortable) sortable.enable();\n\t    return orig_unlock.call(self);\n\t  });\n\t  self.on('initialize', () => {\n\t    var $control = $(self.control).sortable({\n\t      items: '[data-value]',\n\t      forcePlaceholderSize: true,\n\t      disabled: self.isLocked,\n\t      start: (e, ui) => {\n\t        ui.placeholder.css('width', ui.helper.css('width'));\n\t        $control.css({\n\t          overflow: 'visible'\n\t        });\n\t      },\n\t      stop: () => {\n\t        $control.css({\n\t          overflow: 'hidden'\n\t        });\n\t        var values = [];\n\t        $control.children('[data-value]').each(function () {\n\t          if (this.dataset.value) values.push(this.dataset.value);\n\t        });\n\t        self.setValue(values);\n\t      }\n\t    });\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"dropdown_header\" (Tom Select)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction dropdown_header (userOptions) {\n\t  const self = this;\n\t  const options = Object.assign({\n\t    title: 'Untitled',\n\t    headerClass: 'dropdown-header',\n\t    titleRowClass: 'dropdown-header-title',\n\t    labelClass: 'dropdown-header-label',\n\t    closeClass: 'dropdown-header-close',\n\t    html: data => {\n\t      return '<div class=\"' + data.headerClass + '\">' + '<div class=\"' + data.titleRowClass + '\">' + '<span class=\"' + data.labelClass + '\">' + data.title + '</span>' + '<a class=\"' + data.closeClass + '\">&times;</a>' + '</div>' + '</div>';\n\t    }\n\t  }, userOptions);\n\t  self.on('initialize', () => {\n\t    var header = getDom(options.html(options));\n\t    var close_link = header.querySelector('.' + options.closeClass);\n\n\t    if (close_link) {\n\t      close_link.addEventListener('click', evt => {\n\t        preventDefault(evt, true);\n\t        self.close();\n\t      });\n\t    }\n\n\t    self.dropdown.insertBefore(header, self.dropdown.firstChild);\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"dropdown_input\" (Tom Select)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction caret_position () {\n\t  var self = this;\n\t  /**\n\t   * Moves the caret to the specified index.\n\t   *\n\t   * The input must be moved by leaving it in place and moving the\n\t   * siblings, due to the fact that focus cannot be restored once lost\n\t   * on mobile webkit devices\n\t   *\n\t   */\n\n\t  self.hook('instead', 'setCaret', new_pos => {\n\t    if (self.settings.mode === 'single' || !self.control.contains(self.control_input)) {\n\t      new_pos = self.items.length;\n\t    } else {\n\t      new_pos = Math.max(0, Math.min(self.items.length, new_pos));\n\n\t      if (new_pos != self.caretPos && !self.isPending) {\n\t        self.controlChildren().forEach((child, j) => {\n\t          if (j < new_pos) {\n\t            self.control_input.insertAdjacentElement('beforebegin', child);\n\t          } else {\n\t            self.control.appendChild(child);\n\t          }\n\t        });\n\t      }\n\t    }\n\n\t    self.caretPos = new_pos;\n\t  });\n\t  self.hook('instead', 'moveCaret', direction => {\n\t    if (!self.isFocused) return; // move caret before or after selected items\n\n\t    const last_active = self.getLastActive(direction);\n\n\t    if (last_active) {\n\t      const idx = nodeIndex(last_active);\n\t      self.setCaret(direction > 0 ? idx + 1 : idx);\n\t      self.setActiveItem();\n\t      removeClasses(last_active, 'last-active'); // move caret left or right of current position\n\t    } else {\n\t      self.setCaret(self.caretPos + direction);\n\t    }\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"dropdown_input\" (Tom Select)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction dropdown_input () {\n\t  const self = this;\n\t  self.settings.shouldOpen = true; // make sure the input is shown even if there are no options to display in the dropdown\n\n\t  self.hook('before', 'setup', () => {\n\t    self.focus_node = self.control;\n\t    addClasses(self.control_input, 'dropdown-input');\n\t    const div = getDom('<div class=\"dropdown-input-wrap\">');\n\t    div.append(self.control_input);\n\t    self.dropdown.insertBefore(div, self.dropdown.firstChild); // set a placeholder in the select control\n\n\t    const placeholder = getDom('<input class=\"items-placeholder\" tabindex=\"-1\" />');\n\t    placeholder.placeholder = self.settings.placeholder || '';\n\t    self.control.append(placeholder);\n\t  });\n\t  self.on('initialize', () => {\n\t    // set tabIndex on control to -1, otherwise [shift+tab] will put focus right back on control_input\n\t    self.control_input.addEventListener('keydown', evt => {\n\t      //addEvent(self.control_input,'keydown' as const,(evt:KeyboardEvent) =>{\n\t      switch (evt.keyCode) {\n\t        case KEY_ESC:\n\t          if (self.isOpen) {\n\t            preventDefault(evt, true);\n\t            self.close();\n\t          }\n\n\t          self.clearActiveItems();\n\t          return;\n\n\t        case KEY_TAB:\n\t          self.focus_node.tabIndex = -1;\n\t          break;\n\t      }\n\n\t      return self.onKeyDown.call(self, evt);\n\t    });\n\t    self.on('blur', () => {\n\t      self.focus_node.tabIndex = self.isDisabled ? -1 : self.tabIndex;\n\t    }); // give the control_input focus when the dropdown is open\n\n\t    self.on('dropdown_open', () => {\n\t      self.control_input.focus();\n\t    }); // prevent onBlur from closing when focus is on the control_input\n\n\t    const orig_onBlur = self.onBlur;\n\t    self.hook('instead', 'onBlur', evt => {\n\t      if (evt && evt.relatedTarget == self.control_input) return;\n\t      return orig_onBlur.call(self);\n\t    });\n\t    addEvent(self.control_input, 'blur', () => self.onBlur()); // return focus to control to allow further keyboard input\n\n\t    self.hook('before', 'close', () => {\n\t      if (!self.isOpen) return;\n\t      self.focus_node.focus({\n\t        preventScroll: true\n\t      });\n\t    });\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"input_autogrow\" (Tom Select)\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction input_autogrow () {\n\t  var self = this;\n\t  self.on('initialize', () => {\n\t    var test_input = document.createElement('span');\n\t    var control = self.control_input;\n\t    test_input.style.cssText = 'position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ';\n\t    self.wrapper.appendChild(test_input);\n\t    var transfer_styles = ['letterSpacing', 'fontSize', 'fontFamily', 'fontWeight', 'textTransform'];\n\n\t    for (const style_name of transfer_styles) {\n\t      // @ts-ignore TS7015 https://stackoverflow.com/a/50506154/697576\n\t      test_input.style[style_name] = control.style[style_name];\n\t    }\n\t    /**\n\t     * Set the control width\n\t     *\n\t     */\n\n\n\t    var resize = () => {\n\t      test_input.textContent = control.value;\n\t      control.style.width = test_input.clientWidth + 'px';\n\t    };\n\n\t    resize();\n\t    self.on('update item_add item_remove', resize);\n\t    addEvent(control, 'input', resize);\n\t    addEvent(control, 'keyup', resize);\n\t    addEvent(control, 'blur', resize);\n\t    addEvent(control, 'update', resize);\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"input_autogrow\" (Tom Select)\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction no_backspace_delete () {\n\t  var self = this;\n\t  var orig_deleteSelection = self.deleteSelection;\n\t  this.hook('instead', 'deleteSelection', evt => {\n\t    if (self.activeItems.length) {\n\t      return orig_deleteSelection.call(self, evt);\n\t    }\n\n\t    return false;\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"no_active_items\" (Tom Select)\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction no_active_items () {\n\t  this.hook('instead', 'setActiveItem', () => {});\n\t  this.hook('instead', 'selectAll', () => {});\n\t}\n\n\t/**\n\t * Plugin: \"optgroup_columns\" (Tom Select.js)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction optgroup_columns () {\n\t  var self = this;\n\t  var orig_keydown = self.onKeyDown;\n\t  self.hook('instead', 'onKeyDown', evt => {\n\t    var index, option, options, optgroup;\n\n\t    if (!self.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {\n\t      return orig_keydown.call(self, evt);\n\t    }\n\n\t    self.ignoreHover = true;\n\t    optgroup = parentMatch(self.activeOption, '[data-group]');\n\t    index = nodeIndex(self.activeOption, '[data-selectable]');\n\n\t    if (!optgroup) {\n\t      return;\n\t    }\n\n\t    if (evt.keyCode === KEY_LEFT) {\n\t      optgroup = optgroup.previousSibling;\n\t    } else {\n\t      optgroup = optgroup.nextSibling;\n\t    }\n\n\t    if (!optgroup) {\n\t      return;\n\t    }\n\n\t    options = optgroup.querySelectorAll('[data-selectable]');\n\t    option = options[Math.min(options.length - 1, index)];\n\n\t    if (option) {\n\t      self.setActiveOption(option);\n\t    }\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"remove_button\" (Tom Select)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction remove_button (userOptions) {\n\t  const options = Object.assign({\n\t    label: '&times;',\n\t    title: 'Remove',\n\t    className: 'remove',\n\t    append: true\n\t  }, userOptions); //options.className = 'remove-single';\n\n\t  var self = this; // override the render method to add remove button to each item\n\n\t  if (!options.append) {\n\t    return;\n\t  }\n\n\t  var html = '<a href=\"javascript:void(0)\" class=\"' + options.className + '\" tabindex=\"-1\" title=\"' + escape_html(options.title) + '\">' + options.label + '</a>';\n\t  self.hook('after', 'setupTemplates', () => {\n\t    var orig_render_item = self.settings.render.item;\n\n\t    self.settings.render.item = (data, escape) => {\n\t      var item = getDom(orig_render_item.call(self, data, escape));\n\t      var close_button = getDom(html);\n\t      item.appendChild(close_button);\n\t      addEvent(close_button, 'mousedown', evt => {\n\t        preventDefault(evt, true);\n\t      });\n\t      addEvent(close_button, 'click', evt => {\n\t        // propagating will trigger the dropdown to show for single mode\n\t        preventDefault(evt, true);\n\t        if (self.isLocked) return;\n\t        if (!self.shouldDelete([item], evt)) return;\n\t        self.removeItem(item);\n\t        self.refreshOptions(false);\n\t        self.inputState();\n\t      });\n\t      return item;\n\t    };\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"restore_on_backspace\" (Tom Select)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction restore_on_backspace (userOptions) {\n\t  const self = this;\n\t  const options = Object.assign({\n\t    text: option => {\n\t      return option[self.settings.labelField];\n\t    }\n\t  }, userOptions);\n\t  self.on('item_remove', function (value) {\n\t    if (!self.isFocused) {\n\t      return;\n\t    }\n\n\t    if (self.control_input.value.trim() === '') {\n\t      var option = self.options[value];\n\n\t      if (option) {\n\t        self.setTextboxValue(options.text.call(self, option));\n\t      }\n\t    }\n\t  });\n\t}\n\n\t/**\n\t * Plugin: \"restore_on_backspace\" (Tom Select)\n\t * Copyright (c) contributors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n\t * file except in compliance with the License. You may obtain a copy of the License at:\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software distributed under\n\t * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n\t * ANY KIND, either express or implied. See the License for the specific language\n\t * governing permissions and limitations under the License.\n\t *\n\t */\n\tfunction virtual_scroll () {\n\t  const self = this;\n\t  const orig_canLoad = self.canLoad;\n\t  const orig_clearActiveOption = self.clearActiveOption;\n\t  const orig_loadCallback = self.loadCallback;\n\t  var pagination = {};\n\t  var dropdown_content;\n\t  var loading_more = false;\n\t  var load_more_opt;\n\t  var default_values = [];\n\n\t  if (!self.settings.shouldLoadMore) {\n\t    // return true if additional results should be loaded\n\t    self.settings.shouldLoadMore = () => {\n\t      const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);\n\n\t      if (scroll_percent > 0.9) {\n\t        return true;\n\t      }\n\n\t      if (self.activeOption) {\n\t        var selectable = self.selectable();\n\t        var index = [...selectable].indexOf(self.activeOption);\n\n\t        if (index >= selectable.length - 2) {\n\t          return true;\n\t        }\n\t      }\n\n\t      return false;\n\t    };\n\t  }\n\n\t  if (!self.settings.firstUrl) {\n\t    throw 'virtual_scroll plugin requires a firstUrl() method';\n\t  } // in order for virtual scrolling to work,\n\t  // options need to be ordered the same way they're returned from the remote data source\n\n\n\t  self.settings.sortField = [{\n\t    field: '$order'\n\t  }, {\n\t    field: '$score'\n\t  }]; // can we load more results for given query?\n\n\t  const canLoadMore = query => {\n\t    if (typeof self.settings.maxOptions === 'number' && dropdown_content.children.length >= self.settings.maxOptions) {\n\t      return false;\n\t    }\n\n\t    if (query in pagination && pagination[query]) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  };\n\n\t  const clearFilter = (option, value) => {\n\t    if (self.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }; // set the next url that will be\n\n\n\t  self.setNextUrl = (value, next_url) => {\n\t    pagination[value] = next_url;\n\t  }; // getUrl() to be used in settings.load()\n\n\n\t  self.getUrl = query => {\n\t    if (query in pagination) {\n\t      const next_url = pagination[query];\n\t      pagination[query] = false;\n\t      return next_url;\n\t    } // if the user goes back to a previous query\n\t    // we need to load the first page again\n\n\n\t    pagination = {};\n\t    return self.settings.firstUrl.call(self, query);\n\t  }; // don't clear the active option (and cause unwanted dropdown scroll)\n\t  // while loading more results\n\n\n\t  self.hook('instead', 'clearActiveOption', () => {\n\t    if (loading_more) {\n\t      return;\n\t    }\n\n\t    return orig_clearActiveOption.call(self);\n\t  }); // override the canLoad method\n\n\t  self.hook('instead', 'canLoad', query => {\n\t    // first time the query has been seen\n\t    if (!(query in pagination)) {\n\t      return orig_canLoad.call(self, query);\n\t    }\n\n\t    return canLoadMore(query);\n\t  }); // wrap the load\n\n\t  self.hook('instead', 'loadCallback', (options, optgroups) => {\n\t    if (!loading_more) {\n\t      self.clearOptions(clearFilter);\n\t    } else if (load_more_opt && options.length > 0) {\n\t      load_more_opt.dataset.value = options[0][self.settings.valueField];\n\t    }\n\n\t    orig_loadCallback.call(self, options, optgroups);\n\t    loading_more = false;\n\t  }); // add templates to dropdown\n\t  //\tloading_more if we have another url in the queue\n\t  //\tno_more_results if we don't have another url in the queue\n\n\t  self.hook('after', 'refreshOptions', () => {\n\t    const query = self.lastValue;\n\t    var option;\n\n\t    if (canLoadMore(query)) {\n\t      option = self.render('loading_more', {\n\t        query: query\n\t      });\n\n\t      if (option) {\n\t        option.setAttribute('data-selectable', ''); // so that navigating dropdown with [down] keypresses can navigate to this node\n\n\t        load_more_opt = option;\n\t      }\n\t    } else if (query in pagination && !dropdown_content.querySelector('.no-results')) {\n\t      option = self.render('no_more_results', {\n\t        query: query\n\t      });\n\t    }\n\n\t    if (option) {\n\t      addClasses(option, self.settings.optionClass);\n\t      dropdown_content.append(option);\n\t    }\n\t  }); // add scroll listener and default templates\n\n\t  self.on('initialize', () => {\n\t    default_values = Object.keys(self.options);\n\t    dropdown_content = self.dropdown_content; // default templates\n\n\t    self.settings.render = Object.assign({}, {\n\t      loading_more: () => {\n\t        return `<div class=\"loading-more-results\">Loading more results ... </div>`;\n\t      },\n\t      no_more_results: () => {\n\t        return `<div class=\"no-more-results\">No more results</div>`;\n\t      }\n\t    }, self.settings.render); // watch dropdown content scroll position\n\n\t    dropdown_content.addEventListener('scroll', () => {\n\t      if (!self.settings.shouldLoadMore.call(self)) {\n\t        return;\n\t      } // !important: this will get checked again in load() but we still need to check here otherwise loading_more will be set to true\n\n\n\t      if (!canLoadMore(self.lastValue)) {\n\t        return;\n\t      } // don't call load() too much\n\n\n\t      if (loading_more) return;\n\t      loading_more = true;\n\t      self.load.call(self, self.lastValue);\n\t    });\n\t  });\n\t}\n\n\tTomSelect.define('change_listener', change_listener);\n\tTomSelect.define('checkbox_options', checkbox_options);\n\tTomSelect.define('clear_button', clear_button);\n\tTomSelect.define('drag_drop', drag_drop);\n\tTomSelect.define('dropdown_header', dropdown_header);\n\tTomSelect.define('caret_position', caret_position);\n\tTomSelect.define('dropdown_input', dropdown_input);\n\tTomSelect.define('input_autogrow', input_autogrow);\n\tTomSelect.define('no_backspace_delete', no_backspace_delete);\n\tTomSelect.define('no_active_items', no_active_items);\n\tTomSelect.define('optgroup_columns', optgroup_columns);\n\tTomSelect.define('remove_button', remove_button);\n\tTomSelect.define('restore_on_backspace', restore_on_backspace);\n\tTomSelect.define('virtual_scroll', virtual_scroll);\n\n\treturn TomSelect;\n\n}));\nvar tomSelect=function(el,opts){return new TomSelect(el,opts);} \n//# sourceMappingURL=tom-select.complete.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import realpressQuickSetupNotification from './setup/quick-setup-notification';\nimport realpressDropDownPage from './mixins/wp-dropdown-page';\nimport realpressTomSelect from '../mixins/tom-select';\n\n\ndocument.addEventListener( 'DOMContentLoaded', ( event ) => {\n\trealpressQuickSetupNotification();\n\trealpressDropDownPage();\n\trealpressTomSelect();\n} );\n"],"names":["realpressDropDownPage","dropdownWrapperNodes","document","querySelectorAll","restNamespace","REALPRESS_GLOBAL_OBJECT","rest_namespace","__","wp","i18n","i","length","dropdownWrapperNode","dropDownNode","querySelector","createPageBtnNode","addPageInlineNode","addPageActionNode","addEventListener","style","display","focus","event","stopImmediatePropagation","title","value","alert","data","post_type","post_status","apiFetch","path","method","then","res","status","selectControlNode","tomselect","addOption","id","text","setValue","setAttribute","siteurl","catch","err","console","log","finally","preventDefault","selectNode","editPageNode","viewPageNode","editPageUrl","viewPageUrl","innerHTML","realpressQuickSetupNotification","notificactionNode","remove","TomSelect","realpressTomSelect","select2Nodes","select2Node","settings","maxOptions","multiple","plugins"],"sourceRoot":""}